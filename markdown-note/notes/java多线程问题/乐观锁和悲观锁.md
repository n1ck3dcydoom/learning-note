### 乐观锁

乐观锁顾名思义，就是很乐观，每次去拿数据的时候都认为别人 **不会修改** ，所以不会上锁，但是在 **更新的时候** 会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于 **多读** 的应用类型。

乐观锁并没有自带的实现，需要我们手动实现，常见的实现方式就是在每条数据后面加上版本号 `version` ，用于控制乐观锁。

例如有如下表(goods)：
| id | status(0可以下单,1不可以下单) | version |
|:--:|:-----------------------------:|:-------:|
| 1  |               0               |    0    |

那么我们更新这条记录的时候，有以下操作：
```sql
1. 带上版本号一起查处这条记录
SELECT status, version FROM goods WHERE id = #{id}

2. 更新商品信息，修改status为1
UPDATE goods SET status = 1, version = version + 1 WHERE id = #{id} and version = #{version}
```
可以看到，在乐观锁下，所有的查询的都是假设 **没有** 其他事务会操作这条记录，但是在更新的时候，如果版本号 `version` 不等于 原来的 `version` （即有其他事务已经修改了这条记录，且已经提交），那么这次的更新操作是不允许的。

### 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人 **会修改** ，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语 `synchronized` 关键字的实现也是悲观锁。