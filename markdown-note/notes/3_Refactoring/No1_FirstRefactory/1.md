# 1 重构

## 1.1 重构的第一步————测试

在进行任何重构之前，我们需要保证有着一个可靠的测试环境，这样可以避免绝大多数bug的引入。而且这些测试还比有着 **自我比对的能力** 。

例如告知我：要么这些测试用例都是 "OK" 的，要么显示错误，并且显示错误行号。这些都是在代码中进行的自我校验，而不是程序员自己去来回比对测试结果和预期结果。

## 1.2 分解并重组一个复杂的方法

1. 找出代码的逻辑泥团，并且代码外提，即 `Extract Method` 。

首先找出需要外提的代码块中的 **局部变量** 和 **参数** 。对于没有被修改的变量，我们可以将它们作为参数传入新的方法。对于只有一个变量被修改，我们可以将这个变量作为方法的返回值。

对于方法中的参数命名，如果有必要可以进行重命名。一般来说，变量名需要直接地反映出自己的功能，提高代码的清晰度。

2. 将方法放到正确的位置上去，即 `Move method` 。

绝大多数情况下，方法应该放在它所使用的数据结构的对象中内。

例如：
```
class A{
    ...
    private int getSomethingFromB(B b){
        // do something but only use class B
        ...
    }
}
```
上述代码中的 `getSomething()` 方法只使用到了 `B` 类的对象，所以应当把这个方法体全部搬到 `B` 类中去，然后 `A` 类原来的方法委托由 `B` 类去完成。

例如：
```
class A{
    ...
    private int getSomethingFromB(B b){
        return b.getB();
    }
}
class B{
    ...
    public int getB(){
        // get something from class B
    }
}
```
在这个例子中，将方法搬移位置，意味着有可能需要 **去掉参数** 和 **重命名方法** 。

3. 移除一些不必要的中间变量，即 `Replace temp with query` 。

如果一个方法内需要多次使用某个 **一旦赋值** 就不会在改变的变量，那么可以为这个变量保留一个中间变量。但是如果只有一到两处使用到这个变量，那么我们可以考虑移除这个中间变量。例如：

```
class A{
    private B b;
    public void doSomething(){
        int temp = b.getSomething();
        ...
        // 整个方法只有一处使用这个temp变量
        System.out.println("Total count is : " + String.valueOf(temp));
        // 可以考虑移除这个中间变量
        System.out.println("Total count is : " + String.valueOf(b.getSomething()));
    }
}
```
但是这会带来一些性能上的损失，因为如果使用到了两到三次的话，就会增加查询次数，但是这些查询很容易在中间类中进行优化。

## 1.3 运用多态

对于 `switch` 语句来说，最好不要在另一个对象的属性基础上运用 `switch` 语句，如果非要使用的话，也应该放在对象自己的数据上使用，而不是在别人的数据上使用。

对于使用多态去代替 `switch` 语句，一般是某个代码块中需要根据对象的具体状态，以不同的方式回答相同的问题，例如：

对于 **影片Movie** 来说，有 **定期、活期或者其他租借类型** ，我们很容易写出下列代码：
```
switch(type){
    case Movie.FIXED:
        ....
        break;
    case Moview.CURRENT:
        ....
        break;
    case Moview.OTHER:
        ...
        break;
}
```
如果影片的类型很多，那么这个 `switch` 语句看起来会非常的长，而且如果每个分支做的事情是相通的，如计算租借该类型影片所需要收的费用，但是计算的方式又分别不一样，代码块就会显得臃肿冗余。

如果我们将计算租金的方法封装至一个抽象的 `Movie` 基类，并且让具体的影片类型去继承这个基类，然后分别实现自己的租金计算方法，这样就可以使用多态去代替复杂的 `switch` 代码块了。

但是这里又出现了一个小问题：一部影片可以在生命周期修改自己的类型，但是一个对象无法在生命周期类修改自己所属的类，这里使用 **State模式** 解决这个问题。

![extends1](notes/2_Refactoring/images/extends1.png)