### 1
 
为了避免全表扫描，通常选择在 `where` 语句筛选条件以及 `order by` 上建立索引

### 2

尽量避免在 `where` 语句中判断 `null` 值，这样会造成全表扫描，所以尽量为 `null` 设置默认值

### 3

尽量避免在 `where` 语句中使用 != 或者 <> （不等于）符号，这样会造成全表扫描

### 4

尽量避免在 `where` 语句中使用 `or` ，除非对 `or` 两端的关键字分别建立单列索引（复合索引也不行），使用 `union all` 代替 `or`

### 5

慎用 `in` 和 `not in` ，如果是字符型则可以使用索引，如果是整形数字则会导致索引失效 ，对于连续的数值使用 `between`

### 6

前置 `%` 的模糊检索会导致索引失效

### 7

不要在 `where` 子句中的 `=` 左边进行函数、算术运算或其他表达式运算

### 8

复合索引将遵循最左前缀原则，例如 `a,b,c` 生成的索引是 `a` 、`a,b`、`a,b,c`

**这里需要注意的是：如果查询的字段是 `a,c` ，其实这里用到的索引只有`a`，并不存在 `a,c` 这样的索引**

### 9

考虑使用 `exist` 去代替 `in` ，永远记住一句话 **小表驱动大表**

例如：
```
select * from A where id in(select id from B)

可以看做是：
Set result
for (a : A){
    for (b : B){
        if (a.id = b.id){
            result.add(a.id)
        }
    }
}
可见是一个O(n*m)的复杂度
```
上述SQL会把B表中的所有id缓存下来，然后对每一个A表中的id依次遍历B表，看是否存在，如果存在则加入结果集

如果A表有1万条数据，B表有10万条数据，那么这条语句就会有1万*10万次操作

但如果B表只有100条数据，那么这条语句的操作就只有1万*100次，大大减少

再例如：
```
select * from A where id exists(selct 1 from B where b.id = a.id)

可以看做是：
Set result
for (a : A){
    if (exists(a.id){
        result.add(a.id)
    }
}
可见是一个O(n)的复杂度
```
也就是说 `exists` 不回去遍历子查询中的B表，而是对于每一个A表中的记录，去判断他是否存在于B表，意思就是说无论B表多大，它都只执行 `A.length` 次操作

综上所述：
1. 子查询B表越小越适合用 `in`

2. 子查询B表越大越适合用 `exists`

3. A、B表差不多则 `in` 和 `exists` 性能差不多

4. 永远记住 **小表驱动大表**