# KMP 字符串搜索匹配算法

## KMP算法概念介绍

### 1 前缀

一个字符串，除了最后一个字符外，前面所有字符的顺序组合的集合，称为这个字符串的 **前缀** 。

例如：
```
String A = "Hello"
```

那么字符串 A 的前缀为： { "H" , "He" , "Hel" , "Hell" }

### 2 后缀

同前缀，除了第一个字符以为，后面所有字符的顺序组合的集合，称为这个字符串的 **后缀** 。

例如：
```
String B = "World"
```

那么字符串 B 的后缀为： { "orld" , "rld" , "ld" , "d" }

*对于空串或者只有一个字符的字符串来说，它们没有前缀和后缀*

### 3 部分匹配值

**部分匹配值** 就是前缀和后缀两个集合的交集的子串的最长长度。

例如：
```
String C = "ababa"
```

字符串 C 的前缀集合为{"a", "ab", "aba", "abab"} ，后缀集合为{"baba", "aba", "ba", "a"}

两个集合的交集为{"a", "aba"}，其中最长的元素为"aba"，长度为3。

所以字符串 C 的部分匹配值为 3。

### 4 部分匹配表 (PMT)

部分匹配表 (PMT) 就是用于保存一个字符串每个索引 (index) 位置上的 部分匹配值的数组。

注意：部分匹配表(PMT) **不是**  `next` 数组

例如：

|   模式串   | a | b | c | a | b | c | a | c | a | b |
|:----------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|   index    | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| 部分匹配值 | 0 | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 | 2 |


### 5 next数组

next数组：1、2位固定位0、1，其余为 **部分匹配值数组+1**

重点是如何求next数组，公式如下：
```
          {   0 , j = 0（即next数组的第一项固定为0）
next[j] = {   1 , 首尾重合数为0（即匹配失败）
          {   Max{k|1<k<j 且 P_1 ... P_k-1 = P_j-k-1 ... P_j-1}
```

因为next数组的求解涉及到k值得回溯，意思就是说我们求next是已知前j个元素的next值，然后去求解第j+1个元素的next值

假设我们求next[j+1]，由next数组的定义可知，next[j+1]的值是 *前j个元素的首尾重合的最大个数+1* 。

1. 假设next[j] = k1，则说明 P_1 ... P_k1-1 = P_j-k1+1 ... P_j-1

2. 如果 P_k1 = P_j，那么 P_1 ... P_k1 = P_j-k1+1 ... P_j，即j+1位置的前j个元素的首尾重合最大个数为 k1 + 1

3. 如果P_k1 ≠ P_j