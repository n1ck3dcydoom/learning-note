### Redis的引用场景
1. 五大数据类型：字符串String、列表List、集合Set、有序集合Sorted Set、哈希Hash
2. 基本数据结构：简单字符串sds、双向链表、压缩列表、哈希表、跳表、整数数组

### 除了缓存，还用Redis做过什么?  
保存token、session、分布式锁等等

Redis做这些事为了干嘛

服务无状态！

### 服务无状态
定义：一次请求所需要的所有参数，不依赖于其他服务。要么由请求中全部带下来，要么可以从外部获得（Redis、MySQL）等等，服务器本身不存储任何信息。

Http请求本身是无状态协议，所以为了实现服务 **有状态** ，需要通过其他方式保存额外信息，最常见的手段就是 `session` 。

例如，商品展示服务，订单服务，支付服务等等服务之间，通过http协议传输，那么就需要在最上层服务记录用户购买的具体商品，把它写入session当中，并且将session作为一个参数传递到各个http请求里面。这样在下游的订单、支付服务处理的时候，就可以通过session获得具体的商品信息，甚直用户信息。

很多时候，将服务设计成 **无状态** ，是为了保证 `server` 服务端可以动态的进行横向扩缩容。

这样对于客户端来说，只需要把请求发送到任意一台服务端上处理即可，不必关心请求的上下文（无状态）。如果 `server` 服务端是有状态的，即记录了某次请求的上下文；那么后续客户端的请求也只能继续发送给同一台服务端进行处理才行。

### Redis实现分布式锁
单机服务的本地锁，可以保证单个机器内部的并发的线程安全问题，保证查询和修改操作的原子性。

而服务采用集群方式部署时，单机的本地锁无法在集群内布所有机器之间共享信息，从而失效。

这里就需要引入分布式锁来保证服务集群之间的数据一致性。

#### Redis具体实现
通常使用 Redis 的 `setnx` 命令，配合 `del、expire` 等指令完成加锁、解锁、锁超时等操作

* 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败
* 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以继续通过 SETNX 命令来获取锁
* 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住

#### Redis分布式锁的一些弊端
1. setnx 和 expire 并不是原子性的：
例如当某个线程执行完 setnx 命令后，由于网络通信，或者服务器挂掉等其他外部原因，导致 expire 命令并没有被执行，锁没有超时时间而加锁的线程又异常挂掉了导致锁不会显示释放，从而产生死锁问题。

如何避免 setnx 和 expire **非原子性** 问题？

*使用一条命令 set key value NX EX expireTime 保证原子性，即set + expire + if not exist*

*使用 lua 脚本保证一组命令的原子性*

2. 超时问题
在解决了原子性问题之后，还将面临着锁自动超时的问题。

如果线程A在加锁成功后的业务处理流程上花费了太多时间，即拿到锁后业务处理的时间 > 锁超时的时间，这样导致锁自动释放掉。等线程A完成所有业务操作之后再del锁时，此时的锁已经不存在了。

更严重的是，当线程A加锁后进行自己的业务处理，而此时因为耗时过长导致锁自动释放。又有其他线程B得到了锁，如果线程A和B需要同时写一份数据，这里又产生了线程安全问题。

或者说线程B拿到锁之后，线程A的业务处理完成，把线程B的锁给误删了，导致后续链路继续雪崩下去。

如何避免 **超时问题** ？

*尽量避免对长耗时业务进行加锁*

*可以在加锁的过程种，设置一个当前线程独有的魔数（例如业务名+线程名+其他唯一标识等等构成的字符串），在线程处理完业务需要释放锁时，检查下当前锁的魔数是否和之前加锁的一致，如果不一致，则不要删除当前锁*

![image-20220301131008475](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220301131008475.png)

3. 并发执行问题
问题2是因为先加锁的线程处理时间过长，导致锁超时，而又把其他线程后加的锁给 **误** 释放掉。

还有个更严重的问题，就是并发执行的问题，如图：
![image-20220301131156331](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220301131156331.png)

解决方案如下：
*加锁的过期时间设置足够长，保证业务逻辑能够在持有锁期间执行完成，并且锁由加锁的线程显示释放*
*为加锁的线程设置守护线程，在锁将要过期但是没有释放时，为锁增加过期时间（类似自动续租的功能）*

![image-20220301131454677](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220301131454677.png)

4. 不可重入问题
当一个线程在持有锁的情况下，再次请求加锁。

如果一个锁支持一个线程多次加锁，那么称这个锁为可重入锁；反之则称这个锁位不可重入锁。

Redis可以通过对锁进行重入计数，加锁时计数器+1，解锁是计数器-1，当计数器==0时，释放锁

在java本地线程，通过 `ThreadLocal` 对象保存锁的重入计数器，代码示例如下
```java
pThreadLocal<Map<String, Integer>> LOCKERS
// 加锁
public boolean lock(String key) {
    Map<String, Integer> lockers = LOCKERS.get();
    if (lockers.containsKey(key)) {
        // 存在锁，则重入次数+1
        lockers.put(key, lockers.get(key) + 1);
        return true;
    } else {
        // 不存在当前所，则尝试加锁
        if (SET key uuid NX EX 30) {
            // 加锁成功后，重入次数置为1
            lockers.put(key, 1);
            return true;
        }
    }
    // 加锁失败
    return false;
}
// 解锁
public void unlock(String key) {
    Map<String, Integer> lockers = LOCKERS.get();
    // 解锁时，如果剩余重入次数==1，或者还没有当前锁
    if (lockers.getOrDefault(key, 0) <= 1) {
        // ThreadLocal对象移除锁
        lockers.remove(key);
        // Redis移除锁（即使锁不存在，删除一个不存在的key也不会报错
        DEL key
    } else {
        // 重入次数-1
        lockers.put(key, lockers.get(key) - 1);
    }
}
```

本地记录锁的重入次数是一种高效的方式，但是如果考虑到锁过期时间、本地数据和Redis数据的一致性问题，就会增加代码的复杂性。

另一种可重入锁的实现方式是，直接通过Redis map保存锁和重入计数的状态。Redission对可重入锁的一个简单实现：

![image-20220301132923865](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220301132923865.png)

参数含义：

* keys[1]：即锁key名
* argv[2]：Redission生成的线程的uuid值（即超时问题里面的**魔数**）
* argv[1]：超时时间

使用 `Lua` 脚本保证指令的原子性

1. exists 命令判断锁是否存在

2. 如果不存在，则使用hincrby指令创建map，并且把线程的魔数字段值+1，（等效于hset keys[1] argv[2] 1)
3. 对锁keys[1]添加过期时间

这样通过Redission客户端加锁后，Redis内部的数据结构如下

```
Redis存在名如keys[1]的Hash数据结构
keys[1].key = 线程魔数
keys[1].value = 1

{
	"keys[1]": {
		"线程魔数": "1"
	}
}
```

**加锁互斥**

1. 如果 redis key不存在，则加锁，且放入线程魔数，计数器=1
2. 如果 redis key存在，且是当前线程魔数，则计数器++
3. 如果 redis key存在，但不是当前线程魔数（说明锁被其他线程持有），则直接返回当前锁的过期时间

继续讨论分布式锁的弊端

5. 无法等待锁释放

如果客户端可以等待锁释放，需要怎么操作？

*客户端轮询，当未获取到锁时，等待一段时间就查询下锁状态，直到锁释放或者锁超时。性能开销大*

*Redis的订阅和发布功能，当某个线程获取锁失败时，就订阅锁的释放消息。当持有锁的线程释放锁之后，会往消息队列里面发布锁释放的消息，这样其他订阅了的线程就可以尝试继续获得锁。*

![image-20220301135727250](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220301135727250.png)

#### 集群部署下的其他分布式锁问题

1. 主备切换

为了保证Redis的可用性，一般采用主从方式部署。主从之间有同步和异步两种方式完成数据同步。主节点Redis将记录保存在本地内存的buffer当中，然后异步的将buffer当中的指令同步到从节点，从节点一边执行同步指令，一边向主节点反馈同步情况。

当主节点挂掉时，从节点会通过选举产生新的主节点。这一点对于客户端来说是无感知的。

当线程A加锁成功后，主节点挂掉；此时加锁指令还没有同步到新的主节点上，导致后面的其他线程尝试加锁时会成功。

2. 脑裂问题

什么是脑裂？

当因为网络问题，导致Redis的主节点，跟从节点和sentinel集群处于两个不同的网段；而sentinel所在的网段因为只有从节点而感知不到主节点时，会选举产生新的主节点。

此时存在两个不同的主节点，形如一个大脑分裂为两个。

当不同的线程连接到不同的主节点时，两个线程可以同时拥有一把锁，从而导致问题产生。

![image-20220301140501882](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220301140501882.png)