### Redis为什么快

1. Redis是内存数据库，所有操作都是在内存上完成的
2. Redis的键值对是按照一定数据结构来组织的，高效的数据结构是Redis快速处理数据的基础

### Redis的基本数据结构

这是键值对的基本数据类型，数据的保存形式

1. 字符串String
2. 列表List
3. 哈希Hash
4. 集合Set
5. 有序集合Sorted Set

Redis底层的数据结构：

1. 简单动态字符串：String
2. 双向链表：List
3. 压缩链表：List、Hash、Sorted Set
4. 哈希表：Hash、Set
5. 跳表：Sorted Set
6. 整数数组：Set

#### 动态字符串

简单过一下Redis的动态字符串的定义：

```
struct sdshdr{
    // 记录buf数组中已经使用的长度
    int len;
    // 记录buf数组中未使用的长度
    int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```

多出来的 len和free 属性，有什么好处呢？

1. 常数时间复杂度计算字符串长度：在计算当前字符串长度时，可以直接读取len属性获得，其时间复杂度是O(1)；而C语言里面通常是通过遍历数组来计数得到，其时间复杂度是O(n)
2. 避免缓冲区溢出：在做字符串拼接时，如果分配的内存空间不足，则会造成缓冲区溢出。而sds数据类型在做字符串修改时，会根据其free属性来检查内存空间是否满足，如果不满足则会进行相应的扩展，避免了缓冲区溢出的问题
3. 减少内存的分配次数：
4. 空间预分配：一般申请初始化的内存空间要比实际的需要多，这样可以减少执行字符串增长操作带来的内存重新分配次数
5. 空间惰性释放：在做字符串缩短操作时，并不立即回收多余的内存空间，而是通过记录free属性，以便后续可能又重新使用这部分空间
6. 二进制安全：C语言使用 **空字符** 即 **\0** 作为字符串结尾，而如果 **\0** 是我们需要保存的字符，那么可能无法正常存取字符串。sds以二进制的方式处理buf数组里面的元素，使用len属性来判断字符串的结尾

#### 压缩列表

##### 使用场景

1. 如果一个列表包含少量列表项，且每一项都是小整数值或者简单字符串，那么 Redis 就会使用压缩列表作为列表的底层实现
2. 如果一个hash只包含少量键值对，且每个键值对的值都是小整数值或者简单字符串，那么 Redis 就会使用压缩列表作为hash的底层实现

##### 基本数据结构

压缩列表是为了节约内存而开发的，包含任意多个节点(entry)，每个节点存储一个字节数组或者一个整数值

![image-20220222214908586](D:\learning-note\middleware\src\main\java\redis\极客时间\image-20220222214908586.png)

1. zlbytes：长度4个byte，记录整个压缩列表占用的字节数，当进行内存分配，或者计算zlend的时候使用
2. zltail：长度4个byte，记录压缩列表最后一个节点的首地址离整个压缩列表的起始地址的偏移量有多少个字节，可以快速定位到压缩列表的最后一个节点的首地址（即列表的尾节点）
3. zllen：长度2个byte，记录压缩列表包含的节点个数；当实际节点个数小于65535时，这个值就是压缩列表的节点个数；当实际节点个数大于65535时，需要扫描压缩列表才能得到真实的节点个数
4. entry1/entry2/.../entryN：长度不定，由节点实际保存的长度决定
5. zlend：1个byte，压缩列表的尾端，用0xFF标记

##### 节点的表示：

![image-20220222215613287](D:\learning-note\middleware\src\main\java\redis\极客时间\image-20220222215613287.png)每个节点可以保存一个字节数组或者一个整数值，

1. previous_entry_length：保存前一个节点的长度，取值可能是1个byte或者5个byte

* 如果前一个节点的长度小于254字节，那么pel长度为1个byte（8bit，2^8），前一个节点的长度就保存在pel当中
* 如果前一个节点的长度大于等于255字节，那么pel的长度为5个byte，首字节固定为0xFE(254)，之后的4个byte（32bit，2^32）保存前一节点的长度

**为什么临界值时254，8bit能够表示0~255，临界值应该是255才对** 

*因为zlend属性的存在，它的末尾是0xFF即255，为了避免混淆，所以使用0xFE即254以示区分*

2. encoding：记录当前节点的content字段所保存的数据类型，以及conten字段的长度；

encoding保存的内容，取决于content的实际值

字符串：

* 当content是一个字符串时，encoding第一个字节的前两位用于保存字符串长度的**类型编码**，剩下的才是字符串的实际长度
* 当content是一个整数时，encoding第一个字节的前两位固定为**11**，紧跟的后两位表示具体的**整数类型** 
* 00xxxxxx  1字节

长度小于等于2^6-1字节的字符串，2^6-1可以用6位bit表示，所以xxxxxx表示实际字符串的字节长度

* 01xxxxxx|xxxxxxxx  2字节

长度小于等于2^14-1字节的字符串，2^14-1可以用14位bit表示，剩下的14bit表示实际字符串的字节长度

* 10000000|xxxxxxxx|xxxxxxxx|xxxxxxxx|xxxxxxxx  5字节

长度大于2^14-1的字符串，后面32位bit表示实际字符串的字节长度

整数：

* 11000000  3字节

11000000 + int16 （2字节）

* 11010000  5字节

11010000 + int32（4字节）

* 11100000 9字节

11100000 + int64（8字节）

* 11110000  4字节

11110000 + 24位有符号整数（3字节）

* 11111110  2字节

 11111110 + 8位有符号整数 （1字节）

* 1111xxxx

极小整数xxxx范围在（0001-1101）之间，即1-13，但是0000，1110，1111都被占用，需要把xxxx减一，即最终取值范围在0~12之间

* 11111111

表示zlist结束，因为zlend有1字节，固定为0xFF即11111111

**举例说明，一个压缩列表保存了2和5两个节点**

```
[0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]
      |             |          |       |       |     |
   zlbytes        zltail    zllen     "2"     "5"   zlend
```

* zlbytes=0f=15，说明整个压缩列表长度为15个字节
* zltail=0c=12，则说明压缩列表的尾节点首地址距离压缩列表首地址的偏移量为12个字节（头部00，“5”处于第12个字节处）
* zllen=02，则说明压缩列表有2个节点
* 第一个节点“2”，前两位表示上一个节点的长度，因为“2”是第一个节点，所以前两位为00；

f3=11110011，符合1111xxxx的编码规则，说明是一个极小整数，取值value=0011=3，实际值需要减1为“2”

* 第二个节点”5“，前两位02，表示上一个节点的长度为2个字节

f6=11110110，符合1111xxxx的编码规则，说明是一个极小整数，取值value=0110=6，实际值需要减1为“5”

* zlend=ff，固定值表示压缩列表的尾部

**如果把例子换为2和字符串”Hello world“**

```
[1a 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02] [0b] [48 65 6c 6c 6f 20 57 6f 72 6c 64] [ff]
      |             |          |       |     |     
   zlbytes        zltail    zllen     "2"   "5"   
 |
 zlend
```

* zlbytes=1a=26，压缩列表长度为26个字节
* zltail=0c=12，表示尾节点偏移量为12个字节
* zllen=02=2，表示有两个节点
* 第二个节点“Hello world”

第一个字节02=previous_entry_length，表示前一个节点“2”的长度为2个字

第二个字节0b=00001011=encoding，前两位00表示是一个字符串，其长度为001011=11个字节

后面11个字节[48 ~ 64] 对应了字符“Hello world”

* zlend=ff，固定值表示压缩列表的尾部