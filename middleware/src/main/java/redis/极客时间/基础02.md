### Redis为什么快

1. Redis是内存数据库，所有操作都是在内存上完成的
2. Redis的键值对是按照一定数据结构来组织的，高效的数据结构是Redis快速处理数据的基础

### Redis的基本数据结构

这是键值对的基本数据类型，数据的保存形式

1. 字符串String
2. 列表List
3. 哈希Hash
4. 集合Set
5. 有序集合Sorted Set

Redis底层的数据结构：

1. 简单动态字符串：String
2. 双向链表：List
3. 压缩链表：List、Hash、Sorted Set
4. 哈希表：Hash、Set
5. 跳表：Sorted Set
6. 整数数组：Set

#### 动态字符串

简单过一下Redis的动态字符串的定义：

```
struct sdshdr{
    // 记录buf数组中已经使用的长度
    int len;
    // 记录buf数组中未使用的长度
    int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```

多出来的 len和free 属性，有什么好处呢？

1. 常数时间复杂度计算字符串长度：在计算当前字符串长度时，可以直接读取len属性获得，其时间复杂度是O(1)；而C语言里面通常是通过遍历数组来计数得到，其时间复杂度是O(n)
2. 避免缓冲区溢出：在做字符串拼接时，如果分配的内存空间不足，则会造成缓冲区溢出。而sds数据类型在做字符串修改时，会根据其free属性来检查内存空间是否满足，如果不满足则会进行相应的扩展，避免了缓冲区溢出的问题
3. 减少内存的分配次数：
4. 空间预分配：一般申请初始化的内存空间要比实际的需要多，这样可以减少执行字符串增长操作带来的内存重新分配次数
5. 空间惰性释放：在做字符串缩短操作时，并不立即回收多余的内存空间，而是通过记录free属性，以便后续可能又重新使用这部分空间
6. 二进制安全：C语言使用 **空字符** 即 **\0** 作为字符串结尾，而如果 **\0** 是我们需要保存的字符，那么可能无法正常存取字符串。sds以二进制的方式处理buf数组里面的元素，使用len属性来判断字符串的结尾