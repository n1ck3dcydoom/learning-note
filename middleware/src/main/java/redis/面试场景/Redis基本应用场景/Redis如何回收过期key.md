

## Redis的内存回收

1. 后台会轮询，分阶段分批的删除过期的key
2. 请求的时候，在判断是否过期

尽量把内存无用的空间回收起来

#### Redis的淘汰策略

1. 默认策略：不淘汰数据，内存达到阈值时，大部分写指令都将返回错误（del等少数除外）
2. 从所有key中，进行LRU淘汰
3. 从设置了过期时间的key中，进行LRU淘汰
4. 从所有数据中进行随机淘汰
5. 从设置了过期时间的key中，进行随即淘汰
6. 从设置了过期时间的key中，挑选越早过期的数据进行淘汰
7. 从所有key中，进行LFU淘汰（Redis4.0支持）
8. 从设置了过期时间的key中，进行LFU淘汰（Redis4.0支持）



### LRU算法

last recent used 最近最少使用

![image-20220304140906871](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220304140906871.png)

越靠近栈底的对象，未使用的时间就越长

**使用双向列表+hash** 实现LRU算法，java实现为 **LinkedHashMap**

保证了节点的插入顺序和访问顺序一致，每个节点按照插入顺序排列为一个双向链表

![image-20220304141409438](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220304141409438.png)

按照LRU的思想，表头元素就是最早插入的节点（即最旧未使用的节点），表尾元素是最近刚刚插入的节点（即最近使用的节点）

表头元素还有一个head节点，即链表的入口，实际上链表的结构如下：

![image-20220304141602282](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220304141602282.png)





#### Redis如何实现LRU算法

如果按照LinkedHashMap实现LRU，每个节点都需要保存pre和back指针，对内存的空间占用较大

对于LRU来说，redis有两种淘汰策略：

1. 设置了过期时间的key，参与近似LRU淘汰
2. 所有key均参与近似LRU淘汰

redis采取一种 **近似的LRU算法** ：

redisObject有一个时间戳字段，一个24bit的整数

* 首次淘汰时：随机选出【最多N个数据】放入【淘汰数据池pool】

淘汰池pool中的key按照LRU时间戳排序，淘汰池pool的容量默认为16

N默认值5，取到10时将接近理论LRU算法，更加消耗CPU

* 再次淘汰时：随机选出【最多N个数据】，只要数据比【淘汰池pool】当中【任意一个】数据的lru时间戳还要小，则将该数据填充到【淘汰池pool】

接下来将随机选取LRU小于poll中最小LRU的key才放入pool，直到将pool放满

放慢之后，如果有新的key需要继续放入pool，则将pool中lru最大的一个key替换掉

淘汰的时候，从pool中取一个lru最小的key淘汰掉







### Redis的key过期回收

**带有过期时间的key**

1. **定时策略**：每个key带有一个定时器，定时器到达过期时间后，就自动删除key

对内存最友好，可以及时清理过期key，但是每个key都带有一个定时器，对cpu负担大

2. **惰性策略**：不使用定时器，在每次访问一个key的时候，检查这个key的过期时间是否到达，如果过期了，就删除掉

对cpu是最友好的，不用维护定时器；但是如果有些过期的key再也不会被访问了，那这部分key就永远没法清理掉，对内存负担大

3. **定期策略**：每隔一段时间旧扫描过期的key，并进行清理

Redis会将每个设置了过期时间的key，放到一个独立的字典里面，每100ms扫描一次

* 随机抽取N个key
* 删除N个key当中过期的key
* 如果过期key的比例超过1/4，重复步骤1

如果发现某一次回收的key超过了待回收key的1/4，重复回收的过程会期望回收更多的空间

其实Redis的清理策略是1、2的结合

### 主从部署如何清理

redis的主动回收（即1）和被动回收（即2）只会发生在主节点

当主节点redis回收key时，会在aof日志里面记录一条del指令，同步到所有从库

从库通过aof日志同步主库的数据，来执行del删除过期的key



### 惰性删除

由于redis单线程的特性，如果删除的key是一个big key，又或者说执行flushdb、flushall等指令删除包含大量键的数据库时，这个删除操作会导致单线程的卡顿，影响后面的业务读取

引入**惰性删除**，将删除键后者清空数据库的操作放到后台线程取执行，尽可能地避免主线程的阻塞造成的请求超时































## 如何删除过期key



















































































































































