### 为什么要分片

当Redis做RDB持久化的时候，将会fork子进程同时把所有内存全部拷贝给子线程

当主节点的数据量很高时，fork操作将会成为主节点的性能瓶颈

#### 如何保存更多的数据

如果有25G的数据需要保存，单机下至少需要实例有32G内存

如果分为8G的分片，则需要4个*G的实例就可以保存

* 使用更大内存的单个实例，**纵向扩展**
* 使用更多小内存的多个实例，**横向扩展**

![image-20220307171622582](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220307171622582.png)

* 纵向扩展：实现简单

但是做RDB持久化的时候，更大的内存需要更多的时间进行fork操作，主进程阻塞的时间旧更长

更多的内存需要的硬件成本更大。通常经验告诉我们，8个8G的实例要比1个64G的实例更便宜

* 横向扩展：成本更低，扩容方便



#### 横向扩展面临的问题

* 数据分片之后，在多个实例当中如何分布
* 客户端怎么知道自己想要的数据在那个分片当中



#### 数据分片如何分布

Redis提供的方案是 **哈希槽**

一个集群当中，共有 **16384** 个哈希槽

每个键的key都会根据哈希函数映射到对应的哈希槽上

具体过程如下：

1. 通过CRC16算法计算key生成一个16位的hash值
2. 将这个hash值对16384取模，每个数代表一个哈希槽

这些哈希槽在redis集群启动时，会自动把这些槽平均分配到每个实例上

例如有N个实例，每个实例上的哈希槽个数为 16384 / N 个

也可以通过命令手动指定每个实例上的哈希槽个数

一般来说，如果要手动指定哈希槽个数；高配置的实例通常指定更多的哈希槽；而且一旦手动指定哈希槽个数，就必须 **手动指定16384个哈希槽的分配**

#### 客户端如何定位数据

通过CRC16算法和取模处理后，可以得到一个key所在的哈希槽，但是还需要知道计算出来的哈希槽处于哪个实例上

当客户端和集群建立连接之后，实例就会把哈希槽的分配信息发送给客户端。但是，**集群刚刚创建时，每个实例只知道自己被分配了哪些哈希槽，并不知道其他实例的哈希槽信息**

每个redis实例会把自己的哈希槽信息发给和它相连的其他实例，来完成哈希槽分配信息的扩散。当每个实例都完成互相连接之后，每个实例都有所有的哈希槽分配信息了

当客户端收到哈希槽信息之后，会把这份信息缓存到本地。在请求具体键值对时，会现在本地计算所处的哈希槽和实例，然后直接给对应实例发送请求

#### 集群更新哈希槽信息

* 当有新实例加入，或者删除旧实例时，Redis集群需要重新分配哈希槽
* 为了实现负载均衡，Redis集群需要把哈希槽在所有实例上重新分配一边
* 客户端需要感知到什么时候集群更新了哈希槽信息

Redis提供了**重定向机制**，当一个客户端给实例A发送请求时，如果这个实例的哈希槽信息已经改变了，且对应的数据没有保存在当前实例，那么实例A会给客户端返回一个 **重定向** 响应结果

这个**重定向响应结果** 里面包含了对应数据所处的新实例的访问地址

```
moved 6667 172.16.16.5:6379
```

标明客户端当前请求的key，处于新172.16.16.5的节点上的6667槽

这样客户端在收到重定向结果后，会重新向新的实例发送请求得到数据

![image-20220307173655801](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220307173655801.png)

#### 迁移未完成

考虑一个实际情况

如果根据负载均衡，2槽的数据开始从实例2往实例3迁移

当客户端查询实例2时候，2槽里面只有一部分数据迁移到了实例3，还有部分没有完成迁移

这种情况下客户端就会收到一条**ASK报错**

```
(error) ASK 6667 172.16.16.5:6379
```

ASK命令表示，客户端请求的键值对处于6667哈希槽，但是这个哈希槽正在往172.16.16.5实例迁移

此时客户端需要往新的实例发送一条ASKING指令，让新的实例允许执行客户端接下来发送的新指令

然后客户端再向新实例发送get命令，这样最终得到数据

**注意，ask指令不会让客户端刷新本地缓存的哈希槽信息，而且也只允许接下来的一句指令被执行**

所以以后如果还要请求6667迁移中的数据，仍会收到ASK指令，不会和moved一样，更新本地缓存让以后所有命令都往新的实例发送





## 什么是Codis

Codis是Redis的集群解决方案之一，它将多个小内存的Redis实例综合起来，将分布在多个机器上的多个CPU核心的计算能力聚集到一起，形成一个Redis集群

和redis集群不同

Codis默认划分1024个槽位，而非16384个

哈希函数也从CRC16变为CRC32

同时每个槽位都会唯一映射到多个Redis实例，Codis在内部维护槽位和Redis实例的映射关系





































































































































































