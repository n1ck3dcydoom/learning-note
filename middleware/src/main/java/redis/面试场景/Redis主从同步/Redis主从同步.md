## Redis 主从同步

主从节点采用 **读写分离** 的方式

* 读操作：主节点、从节点都能接受和响应
* 写操作：只有主节点执行写操作，然后通过主从同步到从库



### 如何进行主从同步？

当主从节点进行 **第一次数据同步时** 有三个阶段

1. 建立连接、准备进行主从同步；类似于tcp的握手协议

从节点主动向主节点发起连接，通知主节点将进行同步；主节点回复ack之后，连接建立准备开始主从同步

从节点向主节点发送psync指令，包含了 **主节点的runID** 和 **复制进度offset**

![image-20220307135520667](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220307135520667.png)

第一次同步时，从节点并不知道主节点的runID，将会设为 **?**，offset将会设为 **-1** 表示第一次复制

主节点收到psync后，将会以 **FULLSYNC**响应，返回主节点的runID和复制进度offset给从节点

**FULLSYNC表示第一次采用全量复制**

2. 在第二个阶段，从节点接收主节点发送过来的全量RDB文件，同时清空当前的所有数据，开始加载RDB文件
3. 为了避免RDB持久化时，还在继续执行写操作，主节点会将后续更新的写操作写入专门的同步buffer
4. 最后节点为了保证数据的以执行，主节点会把生成RDB文件后继续接受到的写命令通过同步buffer继续推送给从节点，然后从节点再执行这些操作，完成主从同步



#### 一些问题

在主从同步的过程当中，主节点fork子进程生成RDB文件，然后主进程传输RDB文件

这两步操作在数据量过大的情况下，都将给主节点带来压力

**采用级联的主-从-从部署方式减轻主节点的压力**

#### 无盘复制

即直接通过socket将RDB内容直接发送到从节点，不再先生成RDB文件再发送。

主节点一边遍历内存，一遍将序列化的内容发送到从节点

从节点先接收文件存储到磁盘当中，在进行一次性加载



#### 增量同步

全量同步会复制所有数据生成RDB文件，而增量复制会把对数据的操作记录在本地buffer当中，然后异步地将buffer中的指令同步到从节点

从节点一边执行增量命令，一边反馈 **offset偏移量** 到主节点。

Redis采用定长的环形数组来保存增量同步buffer，如果数组内容满了，将会从头部开始覆盖

主库记录写到的位置，从库反馈读到的位置

如果主从之间网络故障持续时间过久，导致从库offset后面的数据还没有获取到，主库就已经覆盖写了

当主库收到从库发送的offset之后，如果主库发现这个offset已经找不到了，将会重新启动一次全量RDB同步



















































































