## 工作线程只有1个

#### 6.x版本后，出现了io多线程

即数据的读取是多线程，但是核心的工作线程仍然只有 **一** 个

#### io多线程

本质是使用epoll（多路复用器）

**多路复用器不负责数据的读写，只负责读写的事件**

redis的工作线程监听到有读写事件发生之后，才会把数据读取到内核做计算和处理

#### 原子性问题

* redis的操作，对于 **单指令** 来说，是原子性的
* 对于 **同一个客户端** 通过 **pipeline** 发送的若干条指令，是原子性的
* 使用 **lua** 脚本提交的指令集，是原子性的
* redis事务？

事务和pipeline的区别

* pipeline是客户端攒了若干条指令，一次性发送到redis
* 事务是客户端前前后后发送了若干条指令，redis攒够之后一次性执行

事务原子性的阶段性结论

* 如果事务提交命令存在语法错误，那么所有命令都不会执行，全部失败
* **如果事务提交命令运行时错误，那么除了错误的命令以外，其他的指令都能正常执行**

能够看到Redis的事务，并没有满足原子性，而且redis也 **不支持回滚操作**

**因为不使用回滚，使redis的内部设计更加简单，更加快速**

lua脚本同样也有这个问题，lua脚本的原子性仅仅保证在某一段lua脚本执行的时候，不会有其他redis指令或者脚本同时执行

如果lua脚本内发生运行时错误，且中途退出。那么已经执行的命令不会回滚，未执行的命令也不会继续执行下去。

#### 单线程模型

![image-20220303191543704](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220303191543704.png)





#### IO多线程模型

曾经的工作线程，需要做 “读取数据” “计算数据” “发送数据”

在引入io多线程之后，“读取数据” “发送数据” 将会进行多线程操作

工作线程会根据epoll的事件分配io线程，去从客户端连接中 “读取数据”

##### io多线程的优势

* 尽可能地提高服务器的资源利用率
* 提高网卡的吞吐量

多个线程同时将网卡输入缓冲区内的数据搬运到redis的程序空间

* 充分利用了多核cpu的能力
* 由于工作线程只关心数据计算，缩短了执行时间

![image-20220303192514577](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220303192514577.png)



##### 总结

多个客户端发送的指令，被读取的顺序不能够被保障

但是单个客户端发送的顺序，在一个socket里面的指令执行顺序是可以被保障的