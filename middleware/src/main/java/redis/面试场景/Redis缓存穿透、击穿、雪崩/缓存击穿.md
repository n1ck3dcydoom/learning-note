## 缓存击穿

当一个热key持续被大并发查询时，**突然过期或者失效**，从而导致大并发请求全部打到数据库

简单来说，击穿和穿透的区别：

* 穿透：查询缓存和db**都不存在**的数据
* 击穿：查询**缓存里没有但是db有**的数据

#### 常见解决方案和弊端

1. 热点key永不过期：

看起来很美好，这样永远避免了key过期带来的击穿问题。

但是同时需要考虑的是：

* 数据库的存储大小远超于缓存的大小，如果少数key永不过期，缓存还能够保存
* 但是从经验来看，热点key绝对不是永远不变的，所以缓存里面哪些永不过期的热点key将会越来越多

2. 加锁

* synchronized：

考虑到发生缓存击穿都是在高并发情况下，肯定都已经是微服务架构，单纯的synchronized锁是绝对无法锁住整个集群的

而且一旦使用了synchronized加锁，会使得所有读redis的请求也加锁，对于读请求加互斥锁是绝对致命的。

* ReentrantLock可重入锁：

可重入的意思是可以被单个线程多次获取，分为 **公平锁** 和 **非公平锁** 

ReentrantLock通过一个FIFO的队列来管理所有获取该锁的线程：

在 **公平锁** 的机制下：所有线程依次排队获取锁

在 **非公平锁** 的机制下：只要锁处于可获取状态，无论线程是否处于队列头部，都会尝试获取锁

 **如果获取一个锁是按照请求的顺序得到的，那么就是公平锁，否则就是非公平锁。**

其默认的是现实非公平锁，在某些极端条件下，可能会造成有些线程永久等待而被饿死

即使使用ReentrantLock，也仅仅是在单机上，对于分布式集群仍然束手无策

3. 分布式锁

使用Redis的setnx指令设置一个key表示一个分布式锁

##### 这里又引入了原生redis分布式锁指令setnx的问题

##### 1. 原子性问题

考虑如下情况：

100个线程并发访问一个失效的，发生缓存击穿现象。

这时所有线程开始尝试加锁，最后有一个线程拿到了锁，如果这个线程挂掉了

那么其他线程就会一直等待这个锁，因为加锁的线程挂掉了，导致锁永远不会被释放，产生了死锁

![image-20220303222748507](D:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220303222748507.png)

**如何解决加锁线程挂掉导致的死锁问题？**

给锁设置超时时间，这样即使加锁线程挂掉了，锁在超时后，仍然会自动释放

问题又来了：加锁和设置过期时间是两条指令，即setnx和expire，如果在setnx后还没来得及expire，线程又挂掉了，那岂不是又出现死锁问题了

**如何保证加锁和设置过期时间的原子性**

1. 使用lua脚本，将setnx和expire放到lua脚本里面一起执行，redis在执行lua脚本时保证一致性
2. 使用redis事务

如果使用multi开启事务后，但是setnx和expire指令发送后没有继续发送exec提交事务，那么事务当中的所有命令都不会执行

只有所有指令都提交，并且提交exec指令后，整个事务当中的指令才会被redis执行

这样即使线程在事务中提交了setnx，还没有提交expire就挂掉，锁也不会被创建出来

3. 高版本的redis当中，set指令支持nx和ex的扩展参数，即 set key value NX EX expireTime 其效果等同于setnx key value and expire key expireTime

##### 2. 锁超时问题

在解决原子性问题之后，考虑如下情况

如果线程A加了锁，并且设置了过期时间

但是A加锁后的业务执行时间过长，超过了锁的过期时间；这时锁自己释放了

随后线程B尝试加锁，并成功拿到了锁

轮到A释放锁的时候，将B加的锁给释放掉了

**如何设置锁的自动过期时间？**

过长，加锁线程死掉其他线程还是会等很久

过短，加锁线程还没拉碟机释放锁，锁就自动超时并且被其他线程拿到

**如何避免释放不是当前线程加的锁**

使用 **线程标识** ，即尝试加锁的时候，在key后面带上当前线程独一无二的标识，称为 **魔数**

例如 set lock_thread1_20220303224401 NX EX 60 

当线程Thread1拿到锁却执行了超过60s，导致锁自行释放后

线程Thread2也加上了锁 set lock_thread2_20220303224552 NX EX 60

此时线程Thread1需要释放自己的锁时，先检查下当前的锁是否是有自己加的，如果不是，就不要释放当前锁

##### 3. 并发执行问题

在考虑了魔数后，来看一种更严重的情况

线程A加锁，然后锁超时，线程B再加锁

如果，**线程A和线程B将会操作同一份数据**，将会产生严重的线程安全问题

这时魔数也不好用了

**不使用魔数，让所有key保持一直，但是加锁的线程自动续租**

当线程A加锁后，并不立马执行自己的业务；而是单独再启动一个**守护线程**

这个**守护线程**定时轮询当前锁的状态，如果发现当前锁即将过期，那么**守护线程**自动为其设置新的过期时间（相当于**Redission的自动续租**）

最后线程A执行完业务后，自行释放掉锁并结束自己的守护线程

##### 4. 可重入问题

##### 5. 等待释放问题

参考[Redis应用场景](..\Redis基本应用场景\Redis应用场景.md)



以上所有考虑，都是处于单节点redis。一般来说，我们通常使用集群的方式部署redis

#### 集群部署redis如何解决缓存击穿问题

如果加锁的那个redis节点挂掉了，当主节点挂掉后，从节点产生新主节点的过程中，有数据不一致的风险

也就是说，锁很有可能丢了

甚至集群因为网络问题，导致主节点 / 从节点和哨兵节点 被划分为看起来是两个集群

而且哨兵节点发现当前集群没有主节点时，会从从节点当中选举产生新的主节点

这样就产生了两个主节点，那么客户端将可能持有两个锁

#### 官方对分布式锁的指导规范——红锁（RedLock）全名（RedisDistributedLock）

保证分布式锁的最低要求如下：

1. 互斥：任何时候都只有一个客户端能够得到分布式锁
2. 避免死锁：即使加锁线程死掉，或者保存锁的redis节点死掉，锁仍然能够正常释放
3. 容错：只要有多数redis节点（一半以上）还正常提供服务，那么客户端就能够正常加锁和释放锁

当redis进行故障转移时，即异步主从备份带来的短暂数据不一致问题发生时，如何让RedLock仍然起效？

如果线程A给主节点加锁成功后，主节点在异步地向从节点复制数据时，主节点挂掉了，导致锁信息没有复制到从节点当中。

然后新选举产生的主节点并没有锁信息，此时线程B也能够成功获得锁，导致锁的互斥性失效

##### 解决方案：

1. 延迟升级：在锁自动失效的时间过后才将从节点升级为主节点
2. 延迟获取：在锁自动失效的时间过后才尝试重新获取新的锁

#### RedLock的实现原理：

假设锁的超时时间为10s

1. 客户端获取当前时间
2. 客户端按照顺序向所有redis节点发起获取锁的申请，将获取锁的等待时间（例如1s），设置远小于锁本身的超时时间（10s）。这样防止在单个节点上等待成功加锁的时间过长，可以跳过出现问题的redis节点，并且尝试向下一个redis节点加锁
3. 客户端在请求了所有能够加锁的节点后，将此时的时间减去第1步的时间；如果这个时间小于锁的超时时间（10s）并且成功加锁的节点个数大于等于redis集群的节点个数的一半+1（N/2+1)，那么认为当前客户端加锁成功
4. 如果成功加锁，锁真正的有效时间是 10s - 第3步得时间差 的时间

例如：锁过期时间10s，获取所有锁用了2s，则真正的锁过期时间为8s，还需要减去时钟漂移带来的时差

5. 如果客户端请求完后的时间已经超过了锁的过期时间，或者成功的节点数不足（N/2+1），那么客户端需要立即向所有的redis节点发送解锁指令，否则将影响其他客户端加锁

例如：

![image-20220303232449836](..\..\极客时间\pic\image-20220303232449836.png)

一共5个redis节点，锁超时时间为10s，单个节点获取锁的等待时间为1s

客户端A花了总共2s，得到了2个redis节点的锁，此时2<(5/2+1)，那么客户端A加锁是不成功的

此时客户端A需要立即向所有的节点发送解锁请求，即使某个节点是加锁失败的

如果redis节点1之前收到了客户端A的加锁请求，且数据已经写入，但是回包的时候网络丢包了导致客户端A没有拿到节点1的锁，而客户端A拿到了节点2,3的锁，此时客户端A加锁失败

若客户端A仅仅向2,3发送解锁请求

那么当客户端B尝试加锁的时候，节点1的网络恢复正常，因为有客户端A的锁存在，所以客户端B本应该拿到节点1的锁，却无法拿到。所以客户端B可能成功加锁却因为客户端A而也加锁失败
