## 缓存击穿

当一个热key持续被大并发查询时，**突然过期或者失效**，从而导致大并发请求全部打到数据库

简单来说，击穿和穿透的区别：

* 穿透：查询缓存和db**都不存在**的数据
* 击穿：查询**缓存里没有但是db有**的数据

#### 常见解决方案和弊端

1. 热点key永不过期：

看起来很美好，这样永远避免了key过期带来的击穿问题。

但是同时需要考虑的是：

* 数据库的存储大小远超于缓存的大小，如果少数key永不过期，缓存还能够保存
* 但是从经验来看，热点key绝对不是永远不变的，所以缓存里面哪些永不过期的热点key将会越来越多

2. 加锁

* synchronized：

考虑到发生缓存击穿都是在高并发情况下，肯定都已经是微服务架构，单纯的synchronized锁是绝对无法锁住整个集群的

而且一旦使用了synchronized加锁，会使得所有读redis的请求也加锁，对于读请求加互斥锁是绝对致命的。

* ReentrantLock可重入锁：

可重入的意思是可以被单个线程多次获取，分为 **公平锁** 和 **非公平锁** 

ReentrantLock通过一个FIFO的队列来管理所有获取该锁的线程：

在 **公平锁** 的机制下：所有线程依次排队获取锁

在 **非公平锁** 的机制下：只要锁处于可获取状态，无论线程是否处于队列头部，都会尝试获取锁

 **如果获取一个锁是按照请求的顺序得到的，那么就是公平锁，否则就是非公平锁。**

其默认的是现实非公平锁，在某些极端条件下，可能会造成有些线程永久等待而被饿死

即使使用ReentrantLock，也仅仅是在单机上，对于分布式集群仍然束手无策

3. 分布式锁

使用Redis的setnx指令设置一个key表示一个分布式锁

##### 这里又引入了原生redis分布式锁指令setnx的问题

考虑如下情况：

100个线程并发访问一个失效的

