### 需要明确一个架构设计上的关键思路

数据库一般是架构设计的瓶颈

即使增加前置环节的复杂度和成本来降低数据库的压力，也是可以接受的

### 什么是缓存穿透

查询一个根本就不存在于缓存和数据库的记录，请求穿过了redis直接打到数据库，导致缓存失去意义。这种现象叫做缓存穿透。

![image-20220303202838564](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220303202838564.png)

### 缓存穿透带来的问题   

正因为redis是单线程的，如果有若干个并发同时请求一个不存在的key

根据单线程的执行流程，第一个被redis接收和处理的请求，会打到数据库；在数据库查询结果返回之前，后续的并发线程将会全部阻塞在redis上，从而导致客户端全部超时。

### 怎样解决缓存穿透

1. key - null：即不存在的key，给它保存一个null的value
2. 布隆过滤器 

##### null value的弊端

如果不经过处理就直接将null对象缓存起来，那么如果一直构造不存在的key进行请求，就造成大量无效的空key出现在redis当中，造成空间的浪费

所以一般通常为空key设置一个较小的过期时间，避免空间的浪费

##### 布隆过滤器

布隆过滤器能够准确快速的判断数据是否存在于大数据集合当中，并且内存占用相对较小

数据结构：

* 一个巨大的bitmap
* 若干个hash函数

当一个数据被添加到布隆过滤器时，通过hash函数算出一个bitmap中的位置值，然后将这个值置1

对于不同的hash函数，将得到不同的位置值置1

![image-20220303204805130](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220303204805130.png)

对于某个输入x，经过若干个hash函数处理之后，得到若干个位置，检查这些所有位置上的标志位

* 如果全部都是1，则说明当前输入 **可能** 存在。因为不同的输入经过hash过后，可能产生hash碰撞导致出现相同的hash结果。
* 如果出现0（无论多少个），则说明的当前输入 **一定** 不存在

##### 使用布隆过滤器处理redis的缓存穿透问题

预先估计所有可能出现的key，使用这些所有可能出现的key初始化布隆过滤器

在请求redis之前，先查询布隆过滤器当中是否存在key，如果不存在key则在业务层就快速失败返回，不再查询redis

##### 布隆过滤器的几个关键参数

- 哈希函数的个数k
- 布隆过滤器位数组的容量m
- 布隆过滤器插入的数据数量n

经过前人们的经验总结，当满足 `k = ln2 * (m/n)` 时，布隆过滤器有最优的准确性





### 其他解决方案

加锁

* 如果是单客户端并发造成的缓存穿透，在单机上通过synchronized关键字加锁控制并发

* 如果是分布式集请求，则需要通过分布式锁来控制并发

考虑如下情况

查缓存 -> 缓存没结果 -> 查数据库 -> 回写缓存 -> 返回结果

1. 在获取数据的方法上加锁：

（查缓存 -> 缓存没结果 -> 查数据库 -> 回写缓存 -> 返回结果），锁粒度过大，所有获取数据的请求将会排队

2. 在查db的地方加锁：

查缓存 -> 缓存没结果 -> （查数据库 -> 回写缓存） -> 返回结果，所有查db的请求将会排队

如果第一个拿到锁的请求，查询了db，并且回写了缓存；后续等待锁的请求仍然会再一次查询db，然后回写缓存，所有请求都将重复这个过程。

**仍然没有解决无效请求达到数据库的现象**

3. 在查db的地方加锁，且加入双重校验机制 （double check）

查缓存 -> 缓存没结果 -> （查缓存 -> 缓存是否有结果 -> 查数据库 -> 回写缓存） -> 返回结果

在同步块中继续查缓存，判断缓存是否有结果；这样第一个请求回写了缓存之后，后续排队查db的请求会因为不通过双重校验从而减少了数据库的请求

**客户端加锁，同时加入双重校验机制，可以最大程度减少缓存穿透的发生，虽然查db也有等待耗时，但是相对于数据库的压力，这是可以接收的**

