## Redis持久方案

### AOF日志

* mysql的日志，通常是写 **前日志** ，也就是说，在实际写数据之前，先把修改的数据写到日志文件当中，以便故障时进行恢复
* redis的aof日志，正好相反是写 **后日志** ，也就是说，先把数据写入到内存后，再记录操作日志

#### AOF日志里面都保存了什么东西？

传统的数据库日志，例如redo log，记录的是修改后的**数据**

而aof日志里面记录的是**每一条指令**，以文本的形式保存

例如 set testkey testvalue

![image-20220305152851600](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220305152851600.png)

* *3表示当前指令有3个部分，每部分都是由**$ + 数字** 构成，后面紧跟着**指令、键、值**等数据
* $3表示当前这部分**指令、键、值**数据占用3字节，**$3 set** 表示 **set** 指令占用3字节

##### 写前日志的好处

* 为了避免额外的检查开销，redis向aof记录日志的时候，不会去检查语法是否正确

在写日志之前，先让redis系统执行指令，如果指令执行失败，则直接向客户端报错，就不再记录aof日志了

指令执行成功后，才记录aof日志

这样在读取aof日志的时候就可以放心大胆的读取，而不用再去检查指令语法，因为只有执行成功的指令才会写入aof日志当中

* 避免阻塞当前写操作

考虑写前日志的情况，如果写日志时发生了异常情况，例如io时间过长等等，导致写日志花费了大量时间，那么当前客户端请求都将阻塞在写日志这里，真实的数据并没得到执行

写后日志则**不会阻塞当前的写操作**

##### aof的风险

1. 如果执行完一条指令之后，还没有记录aof日志系统就挂掉了。那么这条指令和这条指令影响到的数据就有丢失的风险。

如果redis用作缓存，还可以从数据库中恢复数据；如果redis用作存储，那这种情况就无法使用aof日志恢复数据了

2. 虽然aof不会阻塞当前的写操作，但是会给**下一个指令的执行带来风险**。

因为aof同样也是在主线程中执行的，如果记录aof日志写入磁盘时，io有很大的压力就会导致写磁盘非常慢，进而导致后续的指令无法执行下去

##### aof的回写策略

1. always：同步回写，每条指令执行完之后，立马同步地将日志写入磁盘

优势：基本不会丢数据

缺点：不可避免地会影响主线程的性能

2. everysec：每秒回写，每个命令执行完之后，只把日志写入aof的内存缓冲区当中，每间隔1秒再把缓冲区中的内容写入磁盘

优势：减少了同步回写的性能开销

缺点：如果发生节点挂掉，上1秒未写入磁盘的数据仍然会丢失

只是在方案1和方案3中做了折中

3. no：由操作系统控制回写，每个命令执行完之后，只把日志写入aof的内存缓冲区当中，由操作系统决定何时将缓冲区内容写入磁盘

优势：写完缓冲区后，主线程就可以继续处理其他指令

缺点：只要aof没有写入磁盘，一旦redis节点挂掉，数据就丢失了

##### aof的其他风险

随着操作的指令越来越多，相应的aof文件也将会越来越大

1. 操作系统本身对文件大小有限制，无法保存过大的问题件
2. 往过大的文件继续追加写时，效率将变得低下
3. 如果aof文件过大，在进行数据恢复时，整个过程就会非常慢，影响到redis的正常使用

##### aof重写机制——解决aof日志文件过大的问题

在重写时，redis根据**数据库**现有的状况创建一个新的aof文件，但是新的aof文件不会包含任何冗余命令

通俗来说，就是读取**数据库**的所有键值对，对每个键值对使用**一条**命令记录写入操作

例如：

```
rpush list 1 2
rpush list 3
rpush list 4 5
lpop list 
lpop list
rpush 6 7 
lrange list 0 -1
```

最终redis保存的list的值为 `3 4 5 6 7` 

旧的aof日志会记录list的每一个操作

新的aof日志扫描数据库中 list的状态，发现 `list = [3 4 5 6 7]`，就只用一条命令 `rpush list 3 4 5 6 7` 代替前面旧aof日志中记录的6条命令

* 实际运行当中，为了避免大key带来的一条命令操作大量数据，造成缓冲区溢出。当重写程序在处理**list hash set zset**数据结构的时候，会检查操作的元素个数。如果元素个数超过了一个上限值，仍然会使用多条命令来记录当前数据

##### aof的后台重写

普通的aof日志是由主线程写入的，此时主线程会阻塞在磁盘io上

为了避免主线程的阻塞，重写过程是由后台子进程来完成，避免阻塞主线程导致redis性能下降

* 当子进程在进行aof重写时，主进程不必阻塞可以继续处理命令请求
* 子进程是由主线程**fork**得到，带有**主进程的数据副本**，这样就可以把数据逐步写入重写aof日志

##### 子进程aof重写问题

如果子进程在进行aof重写期间，主进程仍然在继续处理后续的指令，而新的指令可能对现有的数据进行修改，这会让当前redis数据库中的数据和重写后的aof日志中的数据不一致

如何解决重写aof日志数据不一致的问题

1. redis增加了一个aof重写缓冲区，当子进程fork出之后启用aof重写缓冲区。redis主进程执行完命令之后，会同时将命令双写到aof缓冲区（旧的aof日志）和aof重写缓冲区（新的aof日志）

这样即使命令执行完，redis挂掉。而旧的aof日志中记录的数据仍然是完整的（重写的新aof日志会因为子进程fork造成数据不一致问题）

![image-20220305160223552](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220305160223552.png)

* 主进程的新操作会被定期和同步写入到旧的aof日志文件中，对现有的aof文件操作正常进行
* 从子进程被fork出来后产生的新指令，主进程会同时记录旧的aof日志和写入aof重写缓冲区。等子进程将拷贝数据写入新aof文件后，也会把aof重写缓冲区的指令写入新的aof文件。最后子进程通过重写aof的新日志文件，替换原来的旧aof日志文件

**aof重写缓冲区是一个不限制大小的buffer，更新数据过多时仍然会造成内存浪费**

### aof总结

总的来说，整个系统设计都遵循一个重要的原则 **trade-off，即”取舍“**，要取得绝对的性能高效和绝对的数据可靠，这是几乎不可能的

系统设计和开发的一个关键哲学就是在性能和可靠之间做出合理的取舍

同时可以看到，使用aof在进行数据恢复时，仍然需要把所有操作记录都遍历一遍，加上redis的单线程设计，只能一条一条地顺序执行，整个恢复的过程仍然是缓慢的



### RDB快照

内存快照（Redis DataBase），把某一时刻的状态，以文件的形式写到磁盘上

和aof相比，快照记录的是某一时刻的**数据**，而非**操作（指令）**。所以在做数据恢复的时候，可以直接把快照读入内存当中，可以很快地完成数据恢复。

**快照的几个关键问题**

1. 对那些数据执行快照？大量快照的话，执行效率也会受到影响
2. 对数据做快照时，如果正好有增删改查的请求操作这部分数据，会导致redis的阻塞吗



#### 1 给哪些数据做快照

redis为了保证所有数据的可靠，默认执行的时**全量快照**

既然是全量数据，那么问题就是**数据越多，快照文件就越大，大文件写入磁盘就越慢**

单线程模型下，大文件的磁盘io会阻塞所有操作，给系统造成不可用

redis提供的快照指令：

1. save：主进程中执行快照，阻塞
2. bgsave：fork一个子进程，专门处理写入快照文件，避免阻塞主进程

#### 2 快照操作时，这些数据还能被修改吗

如果在时刻t给redis做快照操作，假设全量数据是4GB，磁盘写入速度为0.2GB/s

这样至少需要4/0.2=20s才能完成全量快照写入磁盘

假设在t+5的时候，一个偏移量在3GB的数据A被修改为A'

这样就破坏了快照的完整性（因为快照记录的是时刻t的内存状态，而t+5时刻发生的修改破坏了t时刻的状态）

如果在快照的期间，不允许redis主线程对这些数据做写操作的话，这无疑对系统的可用性带来巨大影响（读操作无所谓）

**为了快照而暂停写操作，这是无法接受的**

在RDB当中，有一个很关键的技术支撑**Copy-on-Write 写时复制**

当子进程被主进程fork出来后，可以共享主进程的所有内存空间

**这里也带来了个风险，拷贝主进程的内存页表，是非常耗用cpu资源的**

虽然说fork的子进程是异步写RDB，不会阻塞主进程。但是主进程在fork子进程时，这里必不可少的会阻塞主进程，如果fork实践过长，也将会导致主进程阻塞不可用



回到**写时复制**的技术点。当子进程完成fork之后，如果主进程要写一块数据时。

1. 要写的数据已经被子进程写入到RDB快照了，此时的写入不影响快照记录时刻的状态
2. 要写的数据还没有被子进程写入RDB快照，此时会破坏快照记录时刻的状态

所以主进程将采用**写时复制**的技术，无论修改的数据是否已经被子进程写入RDB快照

都将复制一份副本出来，将写操作应用到复制的副本上。这样子进程的快照状态不会被破坏

![image-20220305165028405](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220305165028405.png)

#### 3 快照记录的时刻

如果RDB记录的时间间隔够短，即使某一时刻发生了故障，也可以从最近的RDB当中恢复，丢失的数据不会太多

![image-20220305165422573](D:\Users\80261561\AppData\Roaming\Typora\typora-user-images\image-20220305165422573.png)

* 频繁地快照会带来很大的磁盘压力，前一个RDB文件还没有写入磁盘，下一个RDB就开始生成了
* 前面提过，fork由于会拷贝主进程的页表引用到子进程（内存共享的实现机制就是主、子进程持有相同的页表引用，拷贝完成后两块空间再慢慢独立开来），这一步操作一定会阻塞主进程的，且主进程的内存越大，阻塞时间越长。

如果频繁地执行RDB操作，将会导致主进程频繁地执行fork操作，就会频繁地阻塞主进程

为此，提出**增量快照**的概念

#### 4 增量快照

在做了一次**全量快照**之后，后续的快照只对修改过的数据进行记录，避免每次都进行全量快照

![image-20220305165920941](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220305165920941.png)

增量快照的问题：

* 有时候为了记录增量修改的元数据信息，反而会引入更大的额外空间消耗，变得得不偿失

#### 5 混合使用aof和rdb

在redis4.0之后，增加了**混合使用aof和rdb**的方法

简单来说，就是rdb以一定的频率执行全量快照；在两次快照之间，使用aof日志记录这期间的所有操作

可以看到在系统设计上，redis再一次在 **性能** 和 **可靠性** 上，做出了 **取舍**

![image-20220305170520038](E:\learning-note\middleware\src\main\java\redis\极客时间\pic\image-20220305170520038.png)



1. 子进程先将fork得到的共享内存，以**全量RDB**的方式，写入aof文件
2. 子进程将aof重写缓冲区新增的命令以**增量**的方式继续写入到aof文件当中
3. 完成后，将**前部分为RDB，后部分为增量AOF**的新aof文件，替换旧的aof文件

当redis进行故障恢复的时候，加载aof文件：

1. 先以rdb的方式恢复数据
2. 再以aof的方式恢复剩下的数



### 对比

1. rdb恢复速度比aof快很多
2. rdb保存的是数据，进行备份的时候比aof方便（aof记录的是指令）
3. 如果非常关新数据安全，建议使用混合方式（redis 4.0开始支持）





### 需要注意的地方

假设机器有4G的内存，redis实例有2G的内存，读写比例为2：8，使用RDB做持久化

* 内存风险

如果写比例高达80%，根据**写时复制**机制，会重新分配80%的内存副本，大约占1.6G，加上原有的redis实例的2G，整个系统的内存使用接近饱和。

如果父进程又有大量新key写入，将面临OOM的风险导致redis进程被系统kill掉，整个服务宕机

如果开启了swap能力，在内存有风险时，会有部分数据被交换到磁盘上。当redis读取这部分磁盘上的数据时，性能会急剧下降



































































































































