## 如何处理消息队列的重复消息

首先明确一点,就是消息队列实际工作中,很难没有重复消息产生

大部分消息队列提供了三种级别:

1. 最多一次:保证消息只会被投递一次,避免重复消息产生,但是本身并不可靠,一旦丢失了就永远没法复现丢失的消息
在允许消息丢失的场景下使用这个级别

2. 至少一次:保证消息一定会被消费者消费一次,可能出现少量的重复消息
大多数消息队列的默认级别

3. 恰好一次:保证消息有且只会被消费一次,不会丢失也不会重复消费
最高的可靠性级别

### 消费端如何解决重复消费的问题

最简单也是最有效的方式, **幂等性** 

什么是 **幂等性** ,就是同一个操作执行若干次,其产生的效果与只执行一次的效果是一样的

一个 **幂等** 的方法,使用同样的参数反复调用任何次,其输出的结果都是一样的

对于 **幂等** 的方法,就不用担心重复执行对系统带来的影响

简单的举例,有一个 `set(int x)` 方法,其作用是将余额设置为 x 元

对于一个固定的入参 x, 无论之前的余额是多少,无论执行多少次 `set()` 方法,其最终结果都是将余额设置为 x, 这就是一个幂等的方法

如果消费者的业务逻辑具备 **幂等性** 就无惧重复消息带来的影响

### 如何实现幂等操作

1. 使用带有 **唯一性约束** 的语义操作,例如数据库的 **唯一索引** 约束, **锁** 的约束
redis 的 set if not exist 也符合幂等性的语义

2. 为更新操作设置前提操作
例如每次更新前,都判断某个条件是否生效或满足,只有满足前置条件的请求,才允许更新数据

最简单的操作,就是为我们的数据设置一个 **版本号**, 每次校验这个版本号; 只有消息体和数据的版本号一致时,才允许更新数据

且更新数据后也同步更新版本号+1

想版本号这种 **单向** 的前置条件,可以避免 ABA 问题产生

3. 通用处理方式:检查并记录
也就是说,对于每次消息,都检查一下这个消息是否已经被处理过

最容易想到的方式就是给消息带上一个 **全局唯一** 的 ID,每次消费者都检查这个全局唯一的 ID 是否已经处理过或者记录过

但是分布式系统当中,全局唯一 ID 也是一个难点,想要满足全局唯一,又需要高可用,这是很难平衡的系统难题

并且 **检查消息状态,执行消息处理数据,记录消息状态** 这三个步骤必须满足原子性操作,才能实现真正的幂等

例如消息:全局 ID = 2, 为账户 123 增加 100 元

Consumer A 收到消息,检查 ID=2 的记录没有被消费过,就去处理账户 123 增加 100 元

若 Consumer B 在 A 还没有记录消息状态时,也收到了消息,B 也会去处理账户 123 增加 100 元

这就导致了问题产生,需要使用分布式事务,或者分布式锁来解决; 这些在分布式系统当中,都是比较难解决的问题

