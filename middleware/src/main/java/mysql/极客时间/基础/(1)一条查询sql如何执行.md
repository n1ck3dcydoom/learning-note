## Mysql的基本架构示意图

![image-20220307220910367](D:\learning-note\middleware\src\main\java\mysql\极客时间\pic\image-20220307220910367.png)

总的来说，mysq包含两层：Server层和存储引擎层

#### Server层

* 连接器：管理客户端链接，权限校验
* 分析器：词法分析、语法分析
* 优化器：执行计划生成、索引选择
* 执行器：操作存储引擎，查询数据，返回结果

如果命中缓存则直接返回，不用再做词法、语法分析以及后续步骤

#### 存储引擎层

* InnoDB：最常用，5.5开始的默认存储引擎
* MyISAM
* Memory

##### InnoDB和MyISAM的区别

* InnoDB支持事务，MyISAM不支持事务
* InnoDB支持行级锁，MyISAM仅支持表级锁
* InnoDB支持MVCC，MyISAM不支持MVCC
* InnoDB后续版本支持全文索引

即使是不同的存储引擎，也是 **共用一个Server层**



### 连接器

负责和客户端建立链接，获取权限，维护链接和管理链接

采用经典的TCP三次握手建立连接

简单介绍TCP三次握手

![image-20220307222053023](D:\learning-note\middleware\src\main\java\mysql\极客时间\pic\image-20220307221601185.png)

四次握手

![image-20220307222538567](D:\learning-note\middleware\src\main\java\mysql\极客时间\pic\image-20220307222538567.png)



为什么要等待2个MSL（报文存活最大时长）

考虑最坏的情况，即**客户端发送的最后ACK，超时，服务端重传最后的FIN=1也超时**

客户端在收到服务端的FIN=1后，发送最后的ACK

如果此时立即关闭自己的连接，当最后一个客户端的ACK经过MSL超时后

服务端等待1个MSL没有收到最后的ACK，此时会重传最后的FIN包

由于客户端已经关闭了连接，再也收不到重传的FIN包，自然也不会发送最后的ACK包，这样服务端就**永远也关闭不了**



如果客户端只等待一个MSL，即自己最后一个ACK的超时时间后关闭连接，最坏情况也收不到服务端的超时重传

所以必须等待两个MSL（即**客户端最后一个ACK超时（MSL）+服务端重传的FIN超时（MSL）**）



回到连接器

一旦一个用户成功建立连接，即使后面使用了管理员账号对这个用户的权限做了修改，也不会影响到已经存在的连接权限。只有重新建立连接时，才会使用新的权限设置

##### 连接超时

使用 `show processlist` 查看当前客户端的所有连接，如果一个连接长时间未使用，则连接器会把它自动断开，`wait_timeout` 一般设置为 8个小时

##### 长链接

如果用户建立了连接，且有持续请求，则一直使用一个连接

##### 短连接

每次执行完几次查询后，就释放连接，后续的查询重新建连

**建立连接是一个很复杂的过程，尽量减少短连接的使用；那么一味地使用长连接也没问题吗**

mysql的执行过程当中，有些数据是绑定到连接的内存空间的。这些数据只有在释放连接的时候才会回收，所以长连接累积下来容易造成内存占用过大，OOM

**使用连接池管理数据库连接，配置接连接数、空闲连接数，每隔一段时间检测空闲连接，然后关闭多余的空闲连接**



### 查询缓存

一般会以 “语句” + “结果” 的kv形式缓存到内存当中，命中缓存后就不用继续执行后续的复杂操作

**一般不建议开启缓存**

由于缓存的查询失效非常频繁，而且mysql的机制导致只要有一个更新操作，当前表上的所有缓存都会被清空

对于频繁写的表并不适合开启缓存，对于静态表才适合使用缓存



### 分析器

1. 词法分析：解析sql语句，识别每个字符串的含义
2. 语法分析：解析sql语句，生成解析树，检查关键字段是否存在（表名、列名在这一步得到确定）





### 优化器

经过分析器之后，已经知道当前sql需要做什么了

还需要经过优化器，得到满足sql要求的最优查询方案

* 当表里面存在多个索引时，决定使用那个索引
* 当语句里面有多张表存在关联查询（例如join）时，决定各个表的连接顺序

一条sql可能有多个不同的**执行顺序**，例如从表A中先查然后关联表B，还是从表B中先查在关联表A，优化器就是选择最优的**执行顺序**



### 执行器

1. 开始执行前，先判断当前用户有没有操作目标表的权限

2. 若有权限，则打开表，根据表的存储引擎，调用对应的存储引擎的接口执行sql语句





























