## 什么是事务

就是一组操作，要么全部成功，要么全部失败



## 事务的4大特性

ACID

1. Atomicity：原子性

一个事务当中的操作要么全部成成功，要么全部失败；不会出现部分成功部分失败的情况

2. Consistency：一致性

在事务开始和事务结束以后，数据库的完整性没有得到破坏（？？？？难以理解）

当前事务执行前后数据保持一致，多个事务对同一个数据的读取结果是相同的

3. Isolation：隔离性

数据库允许多个并发事务同时提交对数据的读写能力

* 读未提交，可能导致脏读、不可重复读、幻读
* 读已提交，解决脏读，仍然可能导致不可重复读、幻读
* 可重复读，解决脏读、不可重复读，仍然可能导致幻读
* 串行化，解决上述三种问题

4. Durability：持久性

一旦事务结束后，对数据的操作就是永久的，即使发生故障也不会丢失



## 什么是事务

 就是一组操作，要么全部成功，要么全部失败 

## 事务的4大特性

 ACID

1. Atomicity：原子性 一个事务当中的操作要么全部成成功，要么全部失败；不会出现部分成功部分失败的情况
2. Consistency：一致性 在事务开始和事务结束以后，数据库的完整性没有得到破坏（？？？？难以理解） 当前事务执行前后数据保持一致，多个事务对同一个数据的读取结果是相同的 
3. Isolation：隔离性 数据库允许多个并发事务同时提交对数据的读写能力

* 读未提交，可能导致脏读、不可重复读、幻读
* 读已提交，解决脏读，仍然可能导致不可重复读、幻读
* 可重复读，解决脏读、不可重复读，仍然可能导致幻读
* 串行化，解决上述三种问题

4. Durability：持久性 一旦事务结束后，对数据的操作就是永久的，即使发生故障也不会丢失   



### 事务的并发问题

一旦数据库上有多个并发事务同时执行时，就可能出现以下问题 

1. 脏读  

一个事务读取了另外一个事务提交修改的临时数据，但是另一个事务没有提交回滚了修改

导致第一个事务读到了脏数据

![image-20220307235259532](D:\learning-note\middleware\src\main\java\mysql\极客时间\pic\image-20220307235259532.png)

2. 不可重复读

同一个事务当中，对一个数据多次读取，结果不一致

可能是在两次查询当中，插入了其他事务更新了原有的数据

![image-20220307235330208](D:\learning-note\middleware\src\main\java\mysql\极客时间\pic\image-20220307235330208.png)

3. 幻读

同一个事务当中，多次查询的结果数目不一致

例如一个事务先查询到了3列，而另外一个事务却插入了几条新数据，先前的事务再次查询是出现了几列之前没有的记录（类似产生幻觉）

![image-20220307235344474](D:\learning-note\middleware\src\main\java\mysql\极客时间\pic\image-20220307235344474.png)

**幻读区别于不可重复读**

* 不可重复读，同一份数据前后发生了变化，数量没有变化
* 幻读，数据前后没有发生变化，但是同样的查询条件得到的结果数量不一致



### 4大隔离级别

* 读未提交

一个事务还没提交时，它做的变更就能被别的事务看到。

* 读已提交

一个事务提交之后，它做的变更才会被其他事务看到

* 可重复读

一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的，未提交变更对其他事务也是不可见的

* 串行化

对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

![image-20220307235613348](D:\learning-note\middleware\src\main\java\mysql\极客时间\pic\image-20220307235613348.png)

在不同的隔离级别下，事务A的V1、V2、V3究竟是什么结果

* 读未提交

则V1能够读取到事务B的修改，V1=2

此时事务B没有提交的修改已经能够被事务A看到，后续的V2=2，V3=2

* 读已提交

则V1读不到事务B还没有提交的修改，V1=1

V2事务B已经提交，此时V2=2，V3=2

* 可重复读

V1读不到事务B还没有提交的修改，V1=1

V2即使能够读到事务B已经提交的修改，但是可重复读的要求是**事务对于同一个数据前后必须是一致的**

之前V1=1，所以此时的V2仍然是V2=1，V3=1

* 串行化

当事务A先查询得到值1的后，会对这行记录加锁，此时事务B会被锁住，无法再修改值为2

由于只有事务A操作数据，所以后面的V1=1，V2=1，V3=1



实际上，数据库使用**视图**来确定访问的最终结果

* 读未提交

直接返回记录上的最新值，没有视图

* 读已提交

当每条SQL开始执行时创建，此时的视图包含了其他事务已经commit的修改记录

* 可重复读

当事务开始执行时就创建，而且整个事务期间都是用最初的一张视图（即使别的事务修改了记录，由于当前事务的视图是最开始就创建的，压根就没有包含后续的修改，所以当前事务期间的数据能够保证一致）

* 串行化

通过直接加锁来避免并行访问



### 隔离级别的具体实现

以 **可重复读** 为例

在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条**回滚操作**。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

也就是说，除了记录 **变更记录** ，同时还会记录一条 **相反效果的回滚记录**，前者记录在 **redo log** 后者在 **undo log**

![image-20220308002841653](D:\learning-note\middleware\src\main\java\mysql\极客时间\pic\image-20220308002841653.png)

当前值是4，但是在查询时，**不同时刻**启动的事务，会有不同的**视图**

在视图A、B、C里面，分别记录了数据值1,2,4的状态

这种现象称为**数据库的多版本并发控制（MVCC）**

对于视图C，如果要得到值1，就必须依次执行回滚段里面的回滚操作

即使现在有另外一个事务，正在将4修改为5，这个事务跟视图A、B、C对应的数据不会产生冲突

#### 

#### 怎样通过Undo log来回滚

当一个事务要提交修改时：

1. 给数据加上行锁
2. 将**修改前**的值写入undo log
3. 修改当前值，然后将改行的回滚指针指向undo log修改前的行

![image-20220308004312986](D:\learning-note\middleware\src\main\java\mysql\极客时间\pic\image-20220308004312986.png)

可以看到，undo log是一个链表结构

每行记录产生的db_roll_prt指向回滚段的undo log中的某一条记录

#### 当产生回滚时，当前数据如何在回滚段中找到对应的回滚记录

1. 查询trx_id，该字段记录当前行最后提交的事务id
2. 通过当前视图判断trx_id事务id是否对当前视图可见
3. 如果当前视图对trx_id事务id可见，则说明这条回滚记录就是当前视图内产生的

否则则通过db_roll_ptr向上回溯找上一个修改数据的回滚记录，直到trx_id对当前视图可见



#### 避免使用长事务

长事务意味着会有很多老的视图存在，由于长事务随时都可能发生回滚

所以系统不得不保存所有的老视图用于数据回滚

这就会导致占用大量的存储空间







































