package daimasuixianglu._9_dp;

public class _22_BestTimeToBuyAndSellStockIII {

    public int maxProfit(int[] prices) {
        // 最多完成两笔交易
        // 那么可能完成两笔，可能完成一笔，也有可能一笔都不完成就能拿到最大收益（如果一直跌的话，收益为0反而是最大的）
        // 对于某一天，有若干种状态
        // 1、当天没有股票操作，继续持有股或继续不持有
        // 2、当天第一次买入股票
        // 3、当前第一次卖出股票
        // 4、当天第二次买入股票
        // 5、当天第二次卖出股票

        int n = prices.length;
        // 第一步、定义dp数组
        // 定义dp[i][5]表示第i天的五种状态
        int[][] dp = new int[n + 1][5];

        // 第二步、状态转移方程
        // 考虑第i天

        // 1、如果第i天继续持有，则dp[i][0]=dp[i-1][0]

        // 2、如果第i天第一次买入股票，且i-1天没有股票，则相当于i-1天没有股票操作，则dp[i][1]=dp[i-1][0]-prices[i]
        // 2.1、如果第i天第一次买入股票，且i-1天有股票，则i-1天相当于继续持有第一次买入的股票，则dp[i][1]=dp[i-1][1]
        // dp[i][1]=max(dp[i-1][0]-prices[i], dp[i-1][1])

        // 3、如果第i天第一次卖出股票，且i-1天没有股票，相当于i-1天是第一次卖出股票的状态，则dp[i][2]=dp[i-1][2]
        // 3.1、如果第i天第一次卖出股票，且i-1天有股票，相当于i-1天是第一次买入股票的状态，则dp[i][2]=dp[i-1][1]+prices[i]
        // dp[i][2]=max(dp[i-1][1]+prices[i], dp[i-1][2])

        // 4、如果第i天第二次买入股票，且i-1天没有股票，相当于i-1天是第一次卖出股票的状态，则dp[i][3]=dp[i-1][2]-prices[i]
        // 4.1、如果第i天第二次买入股票，且i-1天有股票，相当于i-1天是第二次买入股票的状态，则dp[i][3]=dp[i-1][3]
        // dp[i][3]=max(dp[i-1][2]-prices[i], dp[i-1][3])

        // 5、如果第i天第二次卖出股票，且i-1天没有股票，相当于i-1天是第二次卖出股票的状态，则dp[i][4]=dp[i-1][4]
        // 5.1、如果第i天第二次卖出股票，且i-1天有股票，相当于i-1天是第二次买入股票的状态，则dp[i][4]=dp[i-1][3]+prices[i]

        // 由状态转移方程可以得到，后续的dp都是由dp[1]得到，且遍历顺序为从前到后
        // 第三步、初始值
        // 第一天什么也不做
        dp[1][0] = 0;
        // 第一天买入
        dp[1][1] = -prices[0];
        // 第一天卖出，相当买了又卖，收益为0
        dp[1][2] = 0;
        // 第一天第二次买入，相当于买了卖了又买
        dp[1][3] = -prices[0];
        // 第一天第二次卖出，相当于买了卖了又买有卖，收益为0
        dp[1][4] = 0;

        for (int i = 2; i <= n; i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = Math.max(dp[i - 1][0] - prices[i - 1], dp[i - 1][1]);
            dp[i][2] = Math.max(dp[i - 1][1] + prices[i - 1], dp[i - 1][2]);
            dp[i][3] = Math.max(dp[i - 1][2] - prices[i - 1], dp[i - 1][3]);
            dp[i][4] = Math.max(dp[i - 1][3] + prices[i - 1], dp[i - 1][4]);
        }
        return Math.max(dp[n][0], Math.max(dp[n][2], dp[n][4]));
    }
}
