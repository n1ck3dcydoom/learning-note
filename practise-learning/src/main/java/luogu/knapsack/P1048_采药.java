package luogu.knapsack;

/**
 * @author zhanglei
 * @version 1.0
 * @description luogu
 * https://www.luogu.com.cn/problem/P1048
 * @date 2021/2/7 16:47
 **/
public class P1048_采药 {

    public static void main(String[] args) {

        int[] c = new int[]{71, 69, 1};
        int[] w = new int[]{100, 1, 2};
        int v = 70;
        System.out.println(test(c, w, v));

    }


    private static int test(int[] c, int[] w, int v) {
        if (c == null || c.length == 0) {
            return 0;
        }
        int n = c.length;
        // 第一步，定义dp数组
        // 设F[i][v]表示，前i个物体 “恰好” 放入容量为v的背包，其最大价值
        int[][] F = new int[n + 1][v + 1];

        // 第二步，初始值
        // 所有物品放入背包容量为0的，价值肯定是0，因为没有物品能够放进去
        for (int i = 0; i <= n; i++) {
            F[i][0] = 0;
        }

        // 第三步，选择，即递推表达式
        // F[i][v] = Max(F[i-1][v], F[i-1][v-c[i]]+w[i])
        // 枚举物品 0 <= i < n
        for (int i = 1; i <= n; i++) {
            // 枚举前i个物品 “恰好” 能够放入1、2、3、... 、v的背包
            // 枚举容量 1 <= j <= v
            for (int j = 1; j <= v; j++) {
                // 对第i件物品做出选择
                // 当前背包容量放不下第i件物品，自然不会放入，则与前i-1件物品相关
                if (j < c[i - 1]) {
                    F[i][j] = F[i - 1][j];
                }
                // 如果当前背包能够放入第i件物品，则考虑要不要放入
                else {
                    F[i][j] = Math.max(F[i - 1][j], F[i - 1][j - c[i - 1]] + w[i - 1]);
                }
            }
        }
        // 返回容量为v时的最大价值
        return F[n][v];
    }

    private static int test1(int[] c, int[] w, int v) {
        int n = c.length;

        // 定义F数组
        // 约定奇数放1，偶数放0
        int[][] F = new int[2][v + 1];

        // 放入初始值
        // 没有物品放入背包的时候，所有容量的背包里面的价值都是0
        for (int i = 0; i <= v; i++) {
            F[0][i] = 0;
        }

        // 遍历物品
        for (int i = 1; i <= n; i++) {
            // 遍历背包
            for (int j = 1; j <= v; j++) {
                // 当前背包放不下当前物品
                // 则当前F[i]的值和上一次F[i-1]的值相关
                if (j < c[i - 1]) {
                    F[i % 2][j] = F[(i - 1) % 2][j];
                }
                // 如果能够放入当前物品
                else {
                    F[i % 2][j] = Math.max(F[(i - 1) % 2][j], F[(i - 1) % 2][j - c[i - 1]] + w[i - 1]);
                }
            }
        }
        return F[n % 2][v];
    }

    private static int test2(int[] c, int[] w, int v) {
        // 淦他娘的，继续优化空间

        // 观察递推表达式：
        // F[i][j] = Max(F[i-1][j], F[i-1][j-c[i]]+w[i])
        // 可以简单地发现，F[i]只依赖于F[i-1]的状态
        // 假如已经计算完成了物品3所处的当前行，即物品3和容量14的所有最优子问题解的时候
        // 当计算物品4时，其实物品1、2两行已经完全用不上了
        // 而且在遍历背包1之后，计算完成F[4][1]时，就已经可以写回F[3][1]
        // 因为旧的F[3][1]已经对下一次计算(F[5][1])完全没用了
        // 同理，根据旧的F[3][2]计算完F[4][2]之后，完全也可以继续把F[4][2]写回F[3][2]
        // 计算完F[4][j]之后，可以完全写回F[3][j]
        // 同理，计算完F[5][j]之后，完全可以继续写回F[4][j]相当于继续写回F[3][j]
        // 这样，我们在计算完F[1][j]之后，后面的物品可以全部依次写回F[1][j]
        // 相当于我们完全可以只是用一个一维数组来保存中间的状态

        // 即：F[j] = Max(F[j], F[j-c[i]]+w[i])

        // 终于理解到为什么可以被优化为一维的空间复杂度之后
        // 再来思考下为什么需要“倒叙”遍历
        // 假设遍历背包容量时从1到x
        // 当计算F[x]时，F[x]所依赖的F[x-c[i]]已经被更新过了！！！
        // 如何理解？
        //       0  1   2   3   4   5   6   7   8   9   10   11   12   13   14
        // 4/40  0  1   1   1   40  41  41  41  42  42  42   42   50   51   51

        // 假设外部物品的遍历到物品4/40
        // 由于只有一个一维数组了
        // 前面的看起来没啥问题，但是在遍历到容量8的时候
        // 在计算F[8]时，Max(F[8], F[8-4]+40) = 80，乍一看，相当于把物品4/40放了两个进去了
        // 这里是因为前面的F[4]已经不是上一层物品的F[4]了，它实际上是当前层物品的F[4]

        // 从二维地推表达式可知：F[i][j] = Max(F[i-1][j], F[i-1][j-c[i]]+w[i])
        // 上面计算F[8]的时候，转换为二维递推表达式可知：
        // F[i][8] = Max(F[i-1][8], F[i-1][8-c[i]]+w[i])
        // 然而实际上却是通过当前物品层的F[8-c[i]]计算得到的F[i][8]
        // 即错误的递推表达式是：F[i][8] = Max(F[i-1][8], F[i][8-c[i]]+w[i])
        // 所以顺序遍历会产生这种问题！！！！！！！！！！

        // 那如果是倒叙遍历呢？
        // 在计算F[14]时，Max(F[14], F[14-c[i]]+w[i])
        // 这里的F[14-c[i]]仍然是上一层的计算结果，还没有被当前层的计算结果覆盖写
        // 因为14-c[i]一定是小于14的，倒叙遍历保证了前面的背包容量一定是上一层物品的结果

        int n = c.length;
        int[] F = new int[v + 1];

        // 遍历物品
        for (int i = 1; i <= n; i++) {
            // “倒叙”遍历背包容量
            for (int j = v; j >= 1; j--) {
                if (j >= c[i - 1]) {
                    F[j] = Math.max(F[j], F[j - c[i - 1]] + w[i - 1]);
                }
            }
        }
        return F[v];
    }
}
