package leetcode.dp.medium;

/**
 * @author n1ck3dcydoom
 * @version 1.0
 * @description leetcode
 * 给定正整数n，找到若干个完全平方数（比如1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
 * <p>
 * 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
 * <p>
 * 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
 * <p>
 *
 * <p>
 * 示例1：
 * <p>
 * 输入：n = 12
 * 输出：3
 * 解释：12 = 4 + 4 + 4
 * 示例 2：
 * <p>
 * 输入：n = 13
 * 输出：2
 * 解释：13 = 4 + 9
 * <p>
 * 提示：
 * <p>
 * 1 <= n <= 10^4
 * <p>
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/perfect-squares
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @date 2021/2/7 22:46
 **/
public class _279_PerfectSquares {

    public static void main(String[] args) {
        System.out.println(numSquares(12));
    }

    public static int numSquares(int n) {
        // 转化成背包问题
        // 给定容量为n的背包
        // 给定物品大小为1、4、9、16.....若干个
        // 物品可以重复放入背包
        // 求满足刚好放满背包的最小物品个数
        // 物品可以无限制使用，是一个“完全背包问题”

        // 第一步，定义dp数组
        // 定义dp[i]表示容量为i的背包能放入最小物品的个数
        // dp[0]什么也不放，dp数组长度=容量+1
        int[] dp = new int[n + 1];

        // 第二步，初始值
        // dp[0]表示背包容量为0能放入的最小物品个数
        // 题目中明确说了 1 <= n <= 10^4
        // 而且0 = 0 * 0并不属于完全平方数
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            dp[i] = Integer.MAX_VALUE;
        }

        // 第三步，选择，即递推表达式
        // 背包问题通常有两层遍历
        // 先遍历背包，然后遍历物品；或者先遍历物品，然后遍历背包
        //
        // 这个题物品上限看似未知，其实仔细分析可以得到
        // 设物品为a
        // 其能放入的最大完全平方数只能小于i
        // 即物品的上限必须满足 a*a <= i

        // 我们随便先从背包或者物品开始遍历，这里先遍历背包
        // 由322题容易得到：
        // 如果当前容量为i，则dp[i]和dp[i-1]、dp[i-4]、dp[i-9]....dp[i-Math.floor(sqrt(i))^2]相关
        // 再求的上一个dp数组后，加上当前减去的背包容量的完全平方数1，即可得到对应的子问题解
        // 在得到所有子问题解之后，求最小值，即可得到最优子问题的解
        // 即dp[i] = Math.min(dp[i-1]+1,dp[i-4]+1,dp[i-Math.floor(sqrt(i))^2]+1)

        for (int i = 1; i <= n; i++) {
            // j*j <= i，表示当前遍历的物品j*j能够放入当前遍历的背包i
            for (int j = 1; j * j <= i; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
}