package leetcode.dp.medium;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @author zhanglei
 * @version 1.0
 * @description leetcode
 * 给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。
 * <p>
 *  
 * <p>
 * 示例 1：
 * <p>
 * 输入：nums = [3,6,5,1,8]
 * 输出：18
 * 解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
 * 示例 2：
 * <p>
 * 输入：nums = [4]
 * 输出：0
 * 解释：4 不能被 3 整除，所以无法选出数字，返回 0。
 * 示例 3：
 * <p>
 * 输入：nums = [1,2,3,4,4]
 * 输出：12
 * 解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。
 *  
 * 提示：
 * <p>
 * 1 <= nums.length <= 4 * 10^4
 * 1 <= nums[i] <= 10^4
 * <p>
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/greatest-sum-divisible-by-three
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @date 2021/2/3 17:09
 **/
public class _1262_GreatestSumDivisibleByThree {

    public static void main(String[] args) {
        int[] nums = new int[]{3, 6, 5, 1, 8};
        System.out.println(maxSumDivThree1(nums));
    }

    public static int maxSumDivThree(int[] nums) {
        // 应该用什么思路去思考一道题？
        // 第一个想法就是，既然是求能被3整除的最大和，那么我一来就把数组求和，然后根据某些条件减去一些数后，就得到最大和
        // 那么问题来了，如果和刚好被3整除，这就是答案
        // 如果和不能被3整除呢？应该怎么继续走下去，思路应该如何发散？
        // 思考：一个数如果不能够被3整除，那么它除以3有什么情况？
        // 1、余0，即能够被3整除
        // 2、余1
        // 3、余2
        // 继续思考：如果数组的和除以3余1，应该通过怎样的筛选得到去掉某些数后的最大和呢？
        // 什么样的情况下会出现除以3余1的现象现象呢，4/3=1..1  (4+3)/3=2...1  (4+3+1)/3=2..2
        // 8/3=2...2  如果8减去一个本身除以3余1的数呢，(8-1)/3=2...1  结果余1了
        // 如果7再减去一个本身除以3余1的数呢，(7-4)/3=1 结果余0整除了

        // 总结：如果数组和除以3余1，我们可以通过数组和减去一个本身除以3余1的数，那么剩下的数的和就能够被3整除
        //      同理，减去两个除以3余2的数，相当于余数少了4，相当于减去了一个除以3余1的数，同理也能够得到剩下的和能够被3整除

        // 同理可得，如果数组和除以3余2，可以减去一个本身除以3余2的数，也可以减去两个除以3余1的数，这样余数也少了2，剩下的数的和能够被3整除

        // 为了保证数组的和最大，在减去对应的数的时候，应该选择最小的数或者最小的和次小的两个数

        int n = nums.length;
        int sum = 0;
        // 余1的数
        List<Integer> mod1 = new ArrayList<>();
        // 余2的数
        List<Integer> mod2 = new ArrayList<>();
        for (int num : nums) {
            if (num % 3 == 1) {
                mod1.add(num);
            } else if (num % 3 == 2) {
                mod2.add(num);
            }
            sum += num;
        }
        // 对mod1和mod2排序
        Collections.sort(mod1);
        Collections.sort(mod2);

        // 从最大和中依次剔除一些数，让sum能够被3整除，或者sum=0

        int temp = 0;
        // 如果sum已经能够被3整除了，直接返回sum
        if (sum % 3 == 0) {
            return sum;
        }
        // 如果sum除以3余1，则剔除一个余1的数，或者剔除两个余2的数
        else if (sum % 3 == 1) {
            // 余1数的集合不为空
            if (!mod1.isEmpty()) {
                temp = Math.max(temp, sum - mod1.get(0));
            }
            // 余2的数集合个数大于等于2
            if (mod2.size() >= 2) {
                temp = Math.max(temp, sum - mod2.get(0) - mod2.get(1));
            }
        }
        // 如果sum除以3余2，则剔除一个余2的数，或者剔除两个余1的数
        else {
            if (mod1.size() >= 2) {
                temp = Math.max(temp, sum - mod1.get(0) - mod1.get(1));
            }
            if (!mod2.isEmpty()) {
                temp = Math.max(temp, sum - mod2.get(0));
            }
        }
        return temp;
    }

    public static int maxSumDivThree1(int[] nums) {
        // 如何思考动态规划
        // 最简单的想法，设计dp[i]表示前i个数构成的能够被3整除的最大和（不一定要把前i个数选择完，但是一定要考虑到第i个数）

        // 如何做出选择呢？
        // 乍一看，选择只有两个，第i个数选择或者不选择加入当前数组和
        // 考虑第i个数可能出现的情况
        // 1、第i个数能够被3整除，那么一定选择它，肯定能够对最大和做出正向贡献
        // 2、第i个数除以3余1
        // 由于dp[i]表示前i个数能够被3整除的最大和，如果选择i，那么它一定是对最大和做出了正向贡献的
        // 既然第i个数不能够被3整除，为什么还要选择它？
        // 考虑如下：
        // 如果在遍历到第i个数时，前面能够被3整除的最大和是a
        // 我现在想要加入i，为了在加入i后能够被3整除，所以需要找到前面除以3余2的最大和，因为加入i后，余2加余1后，刚好能够被3整除了
        // 设除以3余2的最大和为b，如果b+i后大于刚好能够被3整除的a，此时选择i的就能够对最大和做出正向收益
        // 如果b+i小于a，此时就不会选择i了

        // 3、第i个数除以3余2
        // 根据上面的分析可知，如果想要选择i，需要找到前面除以3余1的最大和，这样加入i后，余1加余2后，刚好也能够被3整除了
        // 设前面除以3余1的最大和为c，如果c+i大于刚好能够被3整除的a，此时选择i能够对最大和做出正向收益
        // 如果c+i小于a，此时就不会选择i了

        // 分析完第i个数究竟选不选择后，发现这里的dp数组跟以往的动态规划不一样，它的第i项并不依赖于第i-1项，或者说前i-j=项
        // 这个题的子问题全部转换为考查前i项里面，能够被3整除的最大和a，除以3余1的最大和b，除以3余2的最大和c
        // 每次遍历i后，会更新a、b、c作为下一次遍历的子问题最优解
        // 所以dp数组也可以优化为dp[3]，分别保存a、b、c

        // 第一步、定义dp数组，dp[0] = a, dp[1] = b, dp[2] = c
        int[] dp = new int[3];

        // 第二步、初始值
        // TODO 原初始值，a、b、c都初始化为0
        dp[1] = 0;
        dp[2] = 0;

        // TODO 为什么dp[1]和dp[2]不能初始化为0？
        // dp[1] = Integer.MIN_VALUE;
        // dp[2] = Integer.MIN_VALUE;

        // 因为在下面for循环里面num%3==0，会更新dp[1]和dp[2]的值
        // 如果初始值为0，那么在不余0的情况下，加上i值一定会比原dp[1]或者dp[2]大，这个时候dp[1]可能就不是余1的最大和了
        // 例如 nums = 3, 4
        // 第一轮遍历后dp[0] = dp[1] = dp[2] = 3
        // 第二轮遍历后dp[0] = 7 , dp[1] = 7 , dp[2] = 7， 其中dp[0]和dp[2]全错了

        // 如何避免上述情况出现，我们发现其实是在出现了余数不为0的情况下，dp[1]和dp[2]加上了整除的数导致的错误
        // 这个时候只要保证不更新dp[1]和dp[2]即可

        // 第三步、选择，即递推表达式
        int n = nums.length;
        int[] temp = new int[3];
        for (int num : nums) {
            // TODO 这里为什么需要使用三个临时变量？
            // TODO 每次运算后的值其实是一个临时状态
            // 思考如果在第一次计算temp[0]的时候，已经赋值到dp[0]里面了
            // 那么接下来的计算temp[1]的时候，这里的dp[0]已经不再是原来的dp[0]了，当然计算得到的dp[1]也是错误的
            // 所以需要三个临时变量来保存每次的临时dp[0]、临时dp[1]和临时dp[2]
            temp[0] = 0;
            temp[1] = 0;
            temp[2] = 0;
            // 更新前i项里面能够被3整除的最大和
            if (num % 3 == 0) {
                // 被3整除的数加上余0的数仍然被3整除
                temp[0] = dp[0] + num;
                // 余1的数加上余0的数仍然余1
                temp[1] = dp[1] > 0 ? dp[1] + num : dp[1];
                // 余2的数加上余0的数仍然余2
                temp[2] = dp[2] > 0 ? dp[2] + num : dp[2];
            } else if (num % 3 == 1) {
                // 余2的数加上余1的数，结果就余0
                temp[0] = dp[2] > 0 ? Math.max(dp[0], dp[2] + num) : dp[0];
                // 余0的数加上余1的数，结果就余1
                temp[1] = Math.max(dp[1], dp[0] + num);
                // 余1的数加上余1的数，结果就余2
                temp[2] = dp[1] > 0 ? Math.max(dp[2], dp[1] + num) : dp[2];
            } else {
                // 余1的数加上余2的数，结果就余0
                temp[0] = dp[1] > 0 ? Math.max(dp[0], dp[1] + num) : dp[0];
                // 余2的数加上余2的数，结果就余1
                temp[1] = dp[2] > 0 ? Math.max(dp[1], dp[2] + num) : dp[1];
                // 余0的数加上余2的数，结果就余2
                temp[2] = Math.max(dp[2], dp[0] + num);
            }
            dp[0] = temp[0];
            dp[1] = temp[1];
            dp[2] = temp[2];
        }
        return dp[0];
    }
}