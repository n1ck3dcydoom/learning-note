package leetcode.dp.medium;

/**
 * @author n1ck3dcydoom
 * @version 1.0
 * @description leetcode
 * 附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。
 * <p>
 * 你把要摆放的书 books 都整理好，叠成一摞：从上往下，第 i 本书的厚度为 books[i][0]，高度为 books[i][1]。
 * <p>
 * 按顺序 将这些书摆放到总宽度为 shelf_width 的书架上。
 * <p>
 * 先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。
 * <p>
 * 需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。
 * <p>
 * 每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。
 * <p>
 * 以这种方式布置书架，返回书架整体可能的最小高度。
 * <p>
 * 输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4
 * 输出：6
 * 解释：
 * 3 层书架的高度和为 1 + 3 + 2 = 6 。
 * 第 2 本书不必放在第一层书架上。
 * <p>
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/filling-bookcase-shelves
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/filling-bookcase-shelves
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @date 2021/2/1 20:15
 **/
public class _1105_FillingBookcaseShelves {
    /**
     * 摆放书的顺序与你整理好的顺序相同
     * 这句话翻译一下：每次做决策放哪一层的书顺序必须和题目给的顺序相同
     * 简单来说，就是放好第一本后，才能放第二本书
     * 这里不是贪心里面的每次取最优解
     * 对于 1 3 5 4 2 ，贪心取1、2、3、4、5
     * 题意的动态规划放书的顺序则必须按照1 3 5 4 2进行
     */
    public int minHeightShelves(int[][] books, int shelf_width) {
        // 第i本书的厚度为 books[i][0]，高度为 books[i][1]
        if (books == null || books.length == 0) {
            return 0;
        }
        int n = books.length;
        // 第一步、定义dp数组
        // dp[i]表示放下第i本书之后，书架的最小高度为dp[i]
        int[] dp = new int[n];

        // 第二步、初始值
        // 显然，放第一本书到第一层，最小高度就是第一本书的高度
        dp[0] = books[0][1];

        // 第三步、选择递推表达式
        // 考虑第i本书，当前面i-1本书已经构成了最优解之后，第i本书应该如何放置？
        // 1、如果第i本书放到新的一层，那么dp[i] = dp[i-1] + books[i][1]
        // 即前i-1的最小高度加上第1本书的自身高度

        // 2、如果第i本书放到和i-1本书的同一层
        // 这个时候就转化为第i-2的最小高度和（i-1的最小高度与第i本书的高度的最大值）的关系了
        // TODO 这里怎么理解，如果i和i-1放同一层，怎么转化为i-2的dp值和 i或者i-1层的最大高度之间的关系？
        // 这里相当于是分成两步走：
        // 2.1、先把第i本书放到新的一层，更新dp[i] = dp[i-1] + books[i][1]  (i-1所在层的最小高度加上第i本书的高度)
        // 2.2、看一下i-1能不能从当前层下移到和i相同的一层
        // 如果i所在层能放下i-1，则把i-1下移一层，此时由于i-1被移走了，所以i-1之前所在的层的最优解变为i-2，即dp[i-2]
        // 此时计算dp[i] = Math.min(dp[i], dp[i-2] + Max(books[i-1][1], books[i][1]))

        // 同理，如果i-2也可以继续往下放，那么i-2所在层的最优解变为i-3，即dp[i-2]
        // 此时dp[i] = Math.min(dp[i], dp[i-3] + Max(books[i-2][1], books[i-1][1], books[i][1]))
        // 可以发现，每次比较的max可以缓存起来带往下一层

        // 从第2本开始寻找
        for (int i = 1; i < n; i++) {
            // TODO 求解2.1里面的，如果把第i本书放到新一层的最小高度dp[i]
            dp[i] = dp[i - 1] + books[i][1];
            // 缓存当前层数的最大高度
            int h = books[i][1];
            // 缓存当前层数已有的书的宽度总和，用来判断下一本书还能不能放入当前层
            int w = books[i][0];

            // 从i-1开始向前寻找，试着放入跟i同层
            for (int j = i - 1; j >= 0; j--) {
                // 更新如果把i-1放入与i同层后的宽度综合
                w = w + books[j][0];
                // 如果放入i-1后，超过了书架的最大宽度，则不再放入这本书
                // 此时为什么不继续往前寻找，直到j==0？
                // 因为j-1已经是最优解了
                if (w > shelf_width) {
                    break;
                }
                // 更新把i-1放入与i同层后的最大高度
                h = Math.max(h, books[j][1]);
                // 如果已经判断到最后一本书
                if (j == 0) {
                    // 此时是极端情况，说明所有书都放到同一层了，那么dp[i]的值理所当然的等于所有书的最大高度h
                    dp[i] = Math.min(dp[i], h);
                }
                // TODO 求解2.2里面的，把i-1放入和i同层后的最小高度dp[i]
                // 2.2里面的dp[i-2]、dp[i-3]在这里就是每次往前寻找的第j-1本书
                // 如何理解j-1？
                // j表示i前面的书，如果j下移放入和i同层，那么j之前所在层的最优解变为j-1，即dp[j-1]
                else {
                    dp[i] = Math.min(dp[i], dp[j - 1] + h);
                }
            }
        }
        return dp[n - 1];
    }
}