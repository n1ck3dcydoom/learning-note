package leetcode.dp.medium;

import java.util.ArrayDeque;
import java.util.Deque;

/**
 * Created by n!Ck
 * Date: 2022/10/29
 * Time: 16:59
 * Description:
 */

public class _907_SumOfSubarrayMinimums {

    private static int MOD = 1000000007;

    public static void main(String[] args) {
        // System.out.println(sumSubarrayMins(new int[]{3, 1, 2, 4}));
        System.out.println(sumSubarrayMins(new int[]{11, 81, 94, 43, 3}));
    }

    public static int sumSubarrayMins(int[] arr) {
        // 将题目转化抽象为以下思路:
        // 1. 遍历每个元素 s[i]
        // 2. 以 i 开始往左查找,直到找到第一个严格小于 a[i] 的位置记为 j,若左边不存在严格小于 a[i] 的元素,则记为 -1
        // 3. 以 i 开始往右查找,直到找到第一个严格小于 a[i] 的位置记为 j,若右边不存在严格小于 a[i] 的元素,则记为 n
        // 4. 维护这两个数组 l[] 和 r[],可以计算出左边以 l[j] 开头,右边以 r[j] 结尾的子数组个数有 (i-l[i])*(r[j]-i)
        // 5. 例如 i = 5, l[5] = 2, r[5] = 7 (下标从 0 开始计算)
        // 意思是对于 a[5] 来说,左边第一个小于 a[5] 的元素在 2 号位; 右边第一个小于 a[5] 的元素在 7 号位
        // 那么构成子数组时,以左边开头的选择有 5-2 种(即a[3],a[4],[a5]),到右边结尾的选择有 7-5 种(即a[5],a[6])
        // 一共有 (5-l[5])*(r[5]-5) = 3*2 = 6 种不同的子数组,这 6 个子数组都包含了最小值 a[5]
        // 即 a[5] 对最终答案贡献值为 a[5] * 6

        // 如何查找到 "下一个更小/更大" 的元素,首选单调栈求解
        // 下一个更小的元素,使用单调递增栈,原理如下
        // 单调递增栈:栈里的元素按照从 "栈底" 到 "栈顶" 依次递增排列
        // 这样当元素 a[i] 入栈的时候,如果栈顶元素比 a[i] 更小,这就不符合从栈底到栈顶递增的性质,会把当前栈顶元素弹出
        // 直到当前栈顶元素比 a[i] 小,这个时候 a[i] 入栈才是符合单调递增栈的性质
        // 按照遍历顺序 [0 ~ i-1] 入栈,可以得知,当 a[i] "准备" 入栈的时候,此时的栈顶元素就是左边第一个小于 a[i] 的元素

        // 同理考虑计算右边界的情况,由于需要计算 a[i] 入栈的情况,所以遍历顺序是从尾部往 a[i] 遍历,即 [n-1 ~ i+1]
        // 同样使用单调递增栈,当 a[i] "准备" 入栈的时候,此时栈顶元素就是右边第一个小于 a[i] 的元素

        // 一句话总结 下一个更小/更大的元素 应当使用递增还是递减单调栈
        // 单调递增栈 -> 下一个更小:当元素 e 入栈的时候,为了满足栈内递增的性质,会把所有比 e 更大的元素全部弹出,直到栈空或者栈顶元素小于 e
        // 单调递减栈 -> 下一个更大:当元素 e 入栈的时候,为了满足栈内递减的性质,会把所有比 e 更小的元素全部弹出,直到栈空或者栈顶元素大于 e

        // 上述计算方法的几个细节还需要考虑下
        // 若存在 两个元素 Ai == Aj,满足 i < j 且 [i+1, j-1] 区间内没有比 Ai 更小的元素

        // 若两端 "严格小于"
        // 此时从 Aj 计算左边第一个小于 Aj 的元素的下标, 和从 Ai 开始计算左边第一个小于 Ai 的元素的下标一样
        // 同理从 Ai 计算右边第一个小于 Ai 的元素的下标, 和从 Aj 开始计算右边第一个小于 Aj 的元素的下标一样
        // 相当于将 [Am, An] 的所有子数组计算了 2 遍
        // ......  Ai ...... Aj .......
        // ...[... Ai ...... Aj .].....
        //    m------------------n
        //    ↑----↑-------------↑
        //    ↑--------------↑---↑

        // 若改为两端 "小于等于"
        // ......  Ai ...... Aj .......
        // ...[... Ai ...... Aj .].....
        //    m------------------n
        //    ↑----↑---------↑
        //         ↑---------↑---↑
        // 对 Ai 来说,它本可以覆盖以 [m ~ i] 开头,[i ~ n] 结尾的子数组就少了 [j ~ n] 结尾的部分
        // 对 Aj 来说,它本可以覆盖以 [m ~ j] 开头,[j ~ n] 结尾的子数组就少了 [m ~ i] 开头的部分

        // 若改为一端 "严格小于" 另一端 "小于等于"
        // ......  Ai ...... Aj .......
        // ...[... Ai ...... Aj .].....
        //    m------------------n
        //    ↑----↑-------------↑
        //         ↑---------↑---↑
        // 对 Ai 来说,它能够覆盖   [m ~ i] 开头,[i ~ n] 结尾的子数组,这很好理解
        // 对 Aj 来说,原来能够覆盖 [m ~ j] 开头,[j ~ n] 结尾,变成了 [i ~ j] 开头,[j ~ n] 结尾
        // 中间缺少的 [m ~ i] 开头, [j ~ n] 结尾的子数组,已经在 Ai 里面计算过了
        // 对于开头,两次 [m ~ i] 开头相等,对于结尾 [i ~ n] 肯定包含了 [j ~ n] 的结果,因为 i < j
        // 所以这时的子数组不会出现重复计算,也不会出现漏算的情况

        // 为了方便计算,在实际代码里面,区间都是开区间,这样计算区间内元素个数的时候,不用 +1

        int n = arr.length;
        // 存放左边第一个 "严格小于" i 的元素下标
        int[] left = new int[n];
        // 存放右边第一个 "小于等于" i 的元素下标
        int[] right = new int[n];
        // 构造单调递增栈
        Deque<Integer> stack = new ArrayDeque<>();

        // 第一次查找左边严格小于 a[i] 的元素下标,为了方便计算中间元素的个数,栈里保存元素的下标而非元素值
        for (int i = 0; i < n; i++) {
            // 单调递增栈的栈顶元素 >= 入栈元素,则当入栈时,栈顶元素是第一个 "严格小于" a[i] 的元素
            // 因为和入栈元素相等或者大于入栈元素的栈顶元素都被弹出去了
            while (!stack.isEmpty() && arr[stack.peekLast()] >= arr[i]) {
                stack.pollLast();
            }
            // 若栈空,则说明左边没有 "严格小于" a[i] 的元素,为了方便计算中间的元素个数,设定一个哨兵为 -1
            left[i] = stack.isEmpty() ? -1 : stack.peekLast();
            // 元素 a[i] 的下标 i 入栈
            stack.offerLast(i);
        }
        // 由于复用同一个栈,中间需要清理数据
        stack.clear();
        // 第二次查找右边小于等于 a[i] 的元素下标,由于 a[i] 需要作为最后一个入栈的元素,所以遍历顺序改为倒序遍历
        for (int i = n - 1; i >= 0; i--) {
            // 单调递增栈的栈顶元素 > 入栈元素,则当入栈的时候,栈顶元素是第一个 "小于等于" a[i] 的元素
            // 因为比入栈元素大的栈顶元素都被弹出去了
            while (!stack.isEmpty() && arr[stack.peekLast()] > arr[i]) {
                stack.pollLast();
            }
            // 若栈空,则说明右边不存在 "小于等于" a[i] 的元素,为了方便计算中间元素的个数,设定一个哨兵为 n
            right[i] = stack.isEmpty() ? n : stack.peekLast();
            // 元素 a[i] 的下标 i 入栈
            stack.offerLast(i);
        }

        // 计算每个元素左右两边的贡献度 a[i] * [ (i-left[i]) * (right[i]-i) ]
        // 为了避免溢出，使用 long 保存中间结果
        long res = 0;
        for (int i = 0; i < n; i++) {
            res = (res + (long) (i - left[i]) * (right[i] - i) * arr[i]) % MOD;
        }
        return (int) res;
    }
}
