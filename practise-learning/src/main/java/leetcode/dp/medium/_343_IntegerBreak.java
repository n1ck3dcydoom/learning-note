package leetcode.dp.medium;

/**
 * @author n1ck3dcydoom
 * @version 1.0
 * @description leetcode
 * 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
 *
 * <p>
 * <p>
 * 示例 1:
 * <p>
 * <p>
 * 输入: 2
 * 输出: 1
 * 解释: 2 = 1 + 1, 1 × 1 = 1。
 * <p>
 * 示例 2:
 * <p>
 * <p>
 * 输入: 10
 * 输出: 36
 * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
 * <p>
 * 说明: 你可以假设 n 不小于 2 且不大于 58。
 *
 * <p>
 * <p>
 * 来源：力扣（LeetCode）
 * <p>
 * 链接：https://leetcode-cn.com/problems/integer-break
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @date 2021/2/8 20:56
 **/
public class _343_IntegerBreak {

    public int integerBreak(int n) {

        // 第一步，定义dp数组
        // 定义dp[i]表示对正数i拆分后得到最大乘积
        int[] dp = new int[n + 1];

        // 第二步，初始值
        // 对于正数0和1都没有拆分的意义，因为他们不能被拆分为两个正整数的和
        dp[2] = 1;

        // 第三步，选择，即递推表达式
        // 思考，dp[i]怎么求得

        // 如果从1开始遍历到j  (j < i)
        // 那么i可以被拆分为 j 和 i-j
        // 如果不拆分i-j了，这里就有一个临时的dp[i] = j * (i-j)

        // 如果我们继续拆分i-j呢，相当于是求i-j被拆分后得最大乘积，正是我们的dp数组dp[i-j]
        // 即 dp[i] = j * dp[i-j]

        // 求上述两个选择，继续拆和不拆的最大dp值
        // dp[i] = max(j*(i-j), j*dp[i-j])

        // 思考：如果从1遍历到j，这里每次遍历
        // 都会产生一个dp[i]值，我们需要对每个dp[i]再求一次最大值
        // 即最终的递推表达式应该是：dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]))
        //                                     ↓ 表示每次遍历j时产生的dp[i]
        //                                             ↓表示遍历j时，要不要继续拆分i-j产生的dp[i]

        // 其实写到这里，我发现动态规划的顺序似乎有点问题了
        // 以前第二步就要求写出初始值
        // 这里我发现其实应该是先写出递推表达式，再来思考base case的情况

        // 在处理了01背包问题后，发现其实动态规划的遍历顺序分为（顺序和逆序）两种遍历方式
        // 如果确定遍历的顺序呢？

        // 由递推表达式可知：dp[i]的状态依赖于dp[i-j]，即dp[i]依赖于前面的dp值
        // 所以i的遍历顺序应该是顺序遍历的

        // 顺序遍历i，这里的base case是i=2的情况，所以直接从3开始遍历，直到n
        for (int i = 3; i <= n; i++) {
            // 顺序遍历j，得到每种i-j是否需要拆分的dp值
            // j不能等于i，因为i没法拆分出一个i和0相加的情况
            for (int j = 1; j < i; j++) {
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
}
