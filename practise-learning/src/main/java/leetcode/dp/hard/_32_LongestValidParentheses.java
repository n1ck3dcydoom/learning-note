package leetcode.dp.hard;

/**
 * @author n1ck3dcydoom
 * @version 1.0
 * @description leetcode
 * <p>
 * 给你一个只包含 '('和 ')'的字符串，找出最长有效（格式正确且连续）括号子串的长度。
 * <p>
 * <p>
 * <p>
 * 示例 1：
 * <p>
 * 输入：s = "(()"
 * 输出：2
 * 解释：最长有效括号子串是 "()"
 * 示例 2：
 * <p>
 * 输入：s = ")()())"
 * 输出：4
 * 解释：最长有效括号子串是 "()()"
 * 示例 3：
 * <p>
 * 输入：s = ""
 * 输出：0
 * <p>
 * <p>
 * 提示：
 * <p>
 * 0 <= s.length <= 3 * 104
 * s[i] 为 '(' 或 ')'
 * <p>
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/longest-valid-parentheses
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @date 2021/4/22 23:48
 **/
public class _32_LongestValidParentheses {
    public int longestValidParentheses(String s) {

        if (s == null || s.length() == 0) {
            return 0;
        }

        int n = s.length();

        // 定义dp[i]表示以i结尾的最长有效括号子串的长度
        int[] dp = new int[n];

        // 初始值，dp[0]表示以第一个元素结尾所能构成的最长有效括号长度
        // 一个最短的括号至少要两个字符才能构成，所以第一个元素无论是什么，都无法构成括号，所以长度为0
        dp[0] = 0;

        // 递推表达式
        // 考虑s[i]的所有情况：
        // 1、s[i] == '('
        // 以左括号结尾永远不可能构成有效括号子串，所以dp[i] = 0

        // 2、s[i] == ')'
        // 考察前面一个字符s[i-1]的情况

        // 如果s[i-1] = '('   那么正好s[i]和s[i-1]能够构成一个完成的有效括号，即形如.....() 其长度为2
        // 状态转移：无论i-1前面的字符是什么，加上i-1和i构成的括号长度2，就能得到dp[i]的结果
        // 详细来说，如果i-2也正好是一个有效括号的结尾，那么加上i-1和i构成的括号，i仍然是一个有效括号的结尾，长度等于dp[i-2]+2
        // 如果i-2不是有效括号的结尾，但是i-1和i仍然能构成括号，所以i仍然是一个有效括号的结尾，只不过长度等于0+2
        // 综上所述 dp[i] = dp[i-2] + 2

        // 如果s[i-1] = ')'  即形如   ......))   这个时候就需要考察与i-1匹配的位置，和与i匹配的位置的情况
        // 即形如  (    (...... )    )
        //             x      i-1   i

        // 如果dp[i-1]的长度为0，即表示i-1结尾并不能构成有效括号，自然以i结尾也不能构成有效括号

        // 如果dp[i-1]的长度不等于0，如何求得x的下标这是关键
        // 从dp数组的定义容易得到：如果i-1也是一个有效括号的结尾，那么dp[i-1]表示其最长的子串长度
        // 即从x开始计数到i-1，一共有dp[i-1]个元素
        // 即 {[(i-1)-x]/1}+1 = dp[i-1]
        // 解方程可得 x = i - dp[i-1]
        // 那么与i匹配的位置的下标即是 i-dp[i-1]-1

        // 所以，如果s[i-dp[i-1]-1] == '('
        // 那么dp[i] = dp[i-1] + 2  再加上 i-dp[i-1]-2 前面的所有最长有效括号长度，其原理等同于上面的dp[i-2]的分析过程
        // 所以 dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]

        int res = 0;
        // 开始遍历字符串求dp数组，第一元素永远不可能构成有效括号(括号至少要两个元素)，所以从第二个元素开始遍历
        for (int i = 1; i < n; i++) {
            // 只有是右括号结尾才有机会构成有效括号
            if (s.charAt(i) == ')') {
                // 第一中情况，形如.....()   只需要考察i-1的情况
                if (s.charAt(i - 1) == '(') {
                    // 如果i-1和i构成括号
                    // 这里i-2有数组越界的情况
                    if (i > 2) {
                        dp[i] = dp[i - 2] + 2;
                    } else {
                        dp[i] = 2;
                    }
                }
                // 如果i-1是反括号，形如  ((.....))  ，需要考察和i对应匹配位置 i-dp[i-1]-1的情况
                else {
                    // 如果i-1不能够成有效括号，则不在考虑这种情况
                    if (dp[i - 1] > 0) {
                        // 与i匹配的位置的索引
                        int iMatchPos = i - dp[i - 1] - 1;
                        // 如果与i匹配位置存在
                        // 例如  (())  )  这种情况下，i=4，dp[i-1]=4，此时i-dp[i-1]-1 = -1，即不存在与i匹配的括号
                        // 需要过滤下
                        if (iMatchPos >= 0 && s.charAt(iMatchPos) == '(') {
                            // 加上，i匹配位置前面的最长长度
                            // 跟上面相同，需要判断iMatchPos-1是否越界
                            // 越界条件是iMatchPos = 0 ，需要计算dp[iMatchPos-1]的值，会产生越界
                            if (iMatchPos > 1) {
                                dp[i] = dp[i - 1] + 2 + dp[iMatchPos - 1];
                            } else {
                                dp[i] = dp[i - 1] + 2;
                            }
                        }
                    }
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}